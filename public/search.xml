<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[storm源码编译及本地调试方法]]></title>
      <url>http://maohong.github.io/2016/07/13/storm%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%8F%8A%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><ul>
<li>IDE开发环境：intelliJIdea</li>
<li>JDK1.7  64bit</li>
<li>intelliJIdea安装maven插件，配置好仓库源</li>
<li>intelliJIdea安装clojure插件Cursive（需要注册并获取一个license，否则只能使用30天）</li>
<li>如果需要自己创建clojure项目进行开发，需要安装leiningen，<a href="http://leiningen.org/" target="_blank" rel="external">下载地址</a></li>
</ul>
<h2 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h2><p>从github checkout代码到本地即可，<a href="https://github.com/apache/storm.git" target="_blank" rel="external">https://github.com/apache/storm.git</a></p>
<p>我这里编译的是我们目前正在用的0.10.0版本的代码。</p>
<h2 id="导入idea及编译"><a href="#导入idea及编译" class="headerlink" title="导入idea及编译"></a>导入idea及编译</h2><p>打开idea，新建project，从源码导入，如下：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20160713-storm%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%8F%8A%E8%B0%83%E8%AF%95/1.png" alt=""></p>
<p>导入后，idea会自动根据pom.xml下载相关依赖包，部分依赖包如果下载不到，需要手动添加。完成后，可以看到project的module如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20160713-storm%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%8F%8A%E8%B0%83%E8%AF%95/2.png" alt=""></p>
<a id="more"></a>
<p>这时候，通过idea就可以直接跟踪看源码了，但直接运行storm-starter中的例子还是会报错并提示有些类找不到，经查看是clojure的代码还未编译出class文件。可以在源码目录下执行mvn compile进行编译。</p>
<h2 id="使用idea调试源码"><a href="#使用idea调试源码" class="headerlink" title="使用idea调试源码"></a>使用idea调试源码</h2><p>编译完成后，可以直接启动storm-starter中的例子运行。期间可能出现找不到类，检查classpath，依赖包的scope由provided改为compile。</p>
<p>在源代码中加断点，run或者debug即可。</p>
<blockquote>
<p>2739 [main] INFO  b.s.u.Utils - Using defaults.yaml from resources<br>4546 [main] INFO  b.s.u.Utils - Using defaults.yaml from resources<br>5218 [main] INFO  b.s.zookeeper - Starting inprocess zookeeper at port 2000 and dir /var/folders/c0/0bgvmbb10jz1609_1xjqdsj00000gn/T//eeb57be9-5478-4fa9-ab31-6dfce38e7695<br>5243 [main] INFO  b.s.u.Utils - Using defaults.yaml from resources<br>5340 [main] INFO  b.s.d.nimbus - Starting Nimbus with conf {“topology.builtin.metrics.bucket.size.secs” 60, ……<br>5342 [main] INFO  b.s.d.nimbus - Using default scheduler<br>5360 [main] INFO  b.s.u.StormBoundedExponentialBackoffRetry - The baseSleepTimeMs [1000] the maxSleepTimeMs [30000] the maxRetries [5]<br>5457 [main] INFO  o.a.c.f.i.CuratorFrameworkImpl - Starting<br>5529 [main-EventThread] INFO  o.a.c.f.s.ConnectionStateManager - State change: CONNECTED<br>5531 [main-EventThread] INFO  b.s.zookeeper - Zookeeper state update: :connected:none<br>6569 [main] INFO  b.s.u.StormBoundedExponentialBackoffRetry - The baseSleepTimeMs [1000] the maxSleepTimeMs [30000] the maxRetries [5]<br>6569 [main] INFO  o.a.c.f.i.CuratorFrameworkImpl - Starting<br>6574 [main-EventThread] INFO  o.a.c.f.s.ConnectionStateManager - State change: CONNECTED<br>6605 [main] INFO  b.s.u.StormBoundedExponentialBackoffRetry - The baseSleepTimeMs [1000] the maxSleepTimeMs [30000] the maxRetries [5]<br>6605 [main] INFO  o.a.c.f.i.CuratorFrameworkImpl - Starting<br>6609 [main-EventThread] INFO  o.a.c.f.s.ConnectionStateManager - State change: CONNECTED<br>6609 [main-EventThread] INFO  b.s.zookeeper - Zookeeper state update: :connected:none<br>6617 [main] INFO  b.s.u.StormBoundedExponentialBackoffRetry - The baseSleepTimeMs [1000] the maxSleepTimeMs [30000] the maxRetries [5]<br>6618 [main] INFO  o.a.c.f.i.CuratorFrameworkImpl - Starting<br>6620 [main] INFO  b.s.u.StormBoundedExponentialBackoffRetry - The baseSleepTimeMs [1000] the maxSleepTimeMs [30000] the maxRetries [5]<br>6621 [main] INFO  o.a.c.f.i.CuratorFrameworkImpl - Starting<br>6623 [main-EventThread] INFO  o.a.c.f.s.ConnectionStateManager - State change: CONNECTED<br>6625 [main-EventThread] INFO  o.a.c.f.s.ConnectionStateManager - State change: CONNECTED<br>6649 [main-EventThread] INFO  b.s.zookeeper - Zookeeper state update: :connected:none<br>6652 [main] INFO  b.s.u.StormBoundedExponentialBackoffRetry - The baseSleepTimeMs [1000] the maxSleepTimeMs [30000] the maxRetries [5]<br>6653 [main] INFO  o.a.c.f.i.CuratorFrameworkImpl - Starting<br>6657 [main-EventThread] INFO  o.a.c.f.s.ConnectionStateManager - State change: CONNECTED<br>6671 [main] INFO  b.s.d.supervisor - Starting Supervisor with conf {“topology.builtin.metrics.bucket.size.secs” 60, ……<br>6693 [main] INFO  b.s.u.StormBoundedExponentialBackoffRetry - The baseSleepTimeMs [1000] the maxSleepTimeMs [30000] the maxRetries [5]<br>6694 [main] INFO  o.a.c.f.i.CuratorFrameworkImpl - Starting<br>6697 [main-EventThread] INFO  o.a.c.f.s.ConnectionStateManager - State change: CONNECTED<br>6697 [main-EventThread] INFO  b.s.zookeeper - Zookeeper state update: :connected:none<br>6700 [main] INFO  b.s.u.StormBoundedExponentialBackoffRetry - The baseSleepTimeMs [1000] the maxSleepTimeMs [30000] the maxRetries [5]<br>6701 [main] INFO  o.a.c.f.i.CuratorFrameworkImpl - Starting<br>6704 [main-EventThread] INFO  o.a.c.f.s.ConnectionStateManager - State change: CONNECTED<br>6722 [main] INFO  b.s.d.supervisor - Starting supervisor with id 913c90f6-3f78-4646-8998-aa901ae3c360 at host localhost<br>6725 [main] INFO  b.s.d.supervisor - Starting Supervisor with conf {“topology.builtin.metrics.bucket.size.secs” 60, …..<br>6732 [main] INFO  b.s.u.StormBoundedExponentialBackoffRetry - The baseSleepTimeMs [1000] the maxSleepTimeMs [30000] the maxRetries [5]<br>6732 [main] INFO  o.a.c.f.i.CuratorFrameworkImpl - Starting<br>6736 [main-EventThread] INFO  o.a.c.f.s.ConnectionStateManager - State change: CONNECTED<br>6736 [main-EventThread] INFO  b.s.zookeeper - Zookeeper state update: :connected:none<br>6740 [main] INFO  b.s.u.StormBoundedExponentialBackoffRetry - The baseSleepTimeMs [1000] the maxSleepTimeMs [30000] the maxRetries [5]<br>6741 [main] INFO  o.a.c.f.i.CuratorFrameworkImpl - Starting<br>6744 [main-EventThread] INFO  o.a.c.f.s.ConnectionStateManager - State change: CONNECTED<br>6753 [main] INFO  b.s.d.supervisor - Starting supervisor with id 49c35a73-7500-4ea4-aaa2-4b1c1f231fd4 at host localhost<br>7035 [main] INFO  b.s.d.nimbus - [req 1] Access from:  principal: op:submitTopology<br>7113 [main] INFO  b.s.d.nimbus - Received topology submission for wordCounter with conf {“topology.max.task.parallelism” nil, “topology.submitter.principal” “”, “topology.acker.executors” nil, “topology.max.spout.pending” 20, “storm.zookeeper.superACL” nil, “topology.users” (), “topology.submitter.user” “”, “topology.kryo.register” {“storm.trident.topology.TransactionAttempt” nil, “storm.trident.spout.RichSpoutBatchId” “storm.trident.spout.RichSpoutBatchIdSerializer”}, “topology.kryo.decorators” (), “storm.id” “wordCounter-1-1468420782”, “topology.name” “wordCounter”}<br>7123 [main] INFO  b.s.d.nimbus - nimbus file location:/var/folders/c0/0bgvmbb10jz1609_1xjqdsj00000gn/T//333ed6da-9ef5-4781-bd82-4f315facd4a8/nimbus/stormdist/wordCounter-1-1468420782<br>7152 [main] INFO  b.s.d.nimbus - Activating wordCounter: wordCounter-1-1468420782<br>7346 [main] INFO  b.s.s.EvenScheduler - Available slots: ([“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1028] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1029] [“913c90f6-3f78-4646-8998-aa901ae3c360” 1024] [“913c90f6-3f78-4646-8998-aa901ae3c360” 1025] [“913c90f6-3f78-4646-8998-aa901ae3c360” 1026])<br>7398 [main] INFO  b.s.d.nimbus - Setting new assignment for topology id wordCounter-1-1468420782: #backtype.storm.daemon.common.Assignment{:master-code-dir “/var/folders/c0/0bgvmbb10jz1609_1xjqdsj00000gn/T//333ed6da-9ef5-4781-bd82-4f315facd4a8/nimbus/stormdist/wordCounter-1-1468420782”, :node-&gt;host {“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” “localhost”}, :executor-&gt;node+port {[8 8] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [12 12] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [2 2] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [7 7] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [22 22] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [3 3] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [24 24] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [1 1] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [18 18] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [6 6] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [20 20] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [9 9] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [23 23] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [11 11] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [16 16] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [13 13] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [19 19] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [21 21] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [5 5] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [26 26] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [10 10] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [14 14] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [4 4] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [15 15] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [25 25] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027], [17 17] [“49c35a73-7500-4ea4-aaa2-4b1c1f231fd4” 1027]}, :executor-&gt;start-time-secs {[8 8] 1468420782, [12 12] 1468420782, [2 2] 1468420782, [7 7] 1468420782, [22 22] 1468420782, [3 3] 1468420782, [24 24] 1468420782, [1 1] 1468420782, [18 18] 1468420782, [6 6] 1468420782, [20 20] 1468420782, [9 9] 1468420782, [23 23] 1468420782, [11 11] 1468420782, [16 16] 1468420782, [13 13] 1468420782, [19 19] 1468420782, [21 21] 1468420782, [5 5] 1468420782, [26 26] 1468420782, [10 10] 1468420782, [14 14] 1468420782, [4 4] 1468420782, [15 15] 1468420782, [25 25] 1468420782, [17 17] 1468420782}}<br>7751 [Thread-7] INFO  b.s.d.supervisor - Extracting resources from jar at /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/lib/ant-javafx.jar to /var/folders/c0/0bgvmbb10jz1609_1xjqdsj00000gn/T//29645b09-90e9-4b9a-a657-60c418f92841/supervisor/stormdist/wordCounter-1-1468420782/resources<br>7788 [Thread-8] INFO  b.s.d.supervisor - Launching worker with assignment {:storm-id “wordCounter-1-1468420782”, :executors [[8 8] [12 12] [2 2] [7 7] [22 22] [3 3] [24 24] [1 1] [18 18] [6 6] [20 20] [9 9] [23 23] [11 11] [16 16] [13 13] [19 19] [21 21] [5 5] [26 26] [10 10] [14 14] [4 4] [15 15] [25 25] [17 17]]} for this supervisor 49c35a73-7500-4ea4-aaa2-4b1c1f231fd4 on port 1027 with id 9dd8aeac-1cd6-467a-a84c-2637d0825d99<br>7791 [Thread-8] INFO  b.s.d.worker - Launching worker for wordCounter-1-1468420782 on 49c35a73-7500-4ea4-aaa2-4b1c1f231fd4:1027 with id 9dd8aeac-1cd6-467a-a84c-2637d0825d99 and conf {“topology.builtin.metrics.bucket.size.secs” 60, ……<br>7793 [Thread-8] INFO  b.s.u.StormBoundedExponentialBackoffRetry - The baseSleepTimeMs [1000] the maxSleepTimeMs [30000] the maxRetries [5]<br>7794 [Thread-8] INFO  o.a.c.f.i.CuratorFrameworkImpl - Starting<br>7798 [Thread-8-EventThread] INFO  o.a.c.f.s.ConnectionStateManager - State change: CONNECTED<br>7798 [Thread-8-EventThread] INFO  b.s.zookeeper - Zookeeper state update: :connected:none<br>7801 [Thread-8] INFO  b.s.u.StormBoundedExponentialBackoffRetry - The baseSleepTimeMs [1000] the maxSleepTimeMs [30000] the maxRetries [5]<br>7802 [Thread-8] INFO  o.a.c.f.i.CuratorFrameworkImpl - Starting<br>7805 [Thread-8-EventThread] INFO  o.a.c.f.s.ConnectionStateManager - State change: CONNECTED<br>7809 [Thread-8] INFO  b.s.s.a.AuthUtils - Got AutoCreds []<br>7811 [Thread-8] INFO  b.s.d.worker - Reading Assignments.<br>7881 [Thread-8] INFO  b.s.d.worker - Launching receive-thread for 49c35a73-7500-4ea4-aaa2-4b1c1f231fd4:1027<br>7884 [Thread-9-worker-receiver-thread-0] INFO  b.s.m.loader - Starting receive-thread: [stormId: wordCounter-1-1468420782, port: 1027, thread-id: 0 ]<br>8261 [Thread-8] INFO  b.s.d.executor - Loading executor b-2:[8 8]<br>8285 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-2:[8 8]<br>8300 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-2:[8 8]<br>8311 [Thread-8] INFO  b.s.d.executor - Loading executor b-2:[12 12]<br>8329 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-2:[12 12]<br>8331 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-2:[12 12]<br>8340 [Thread-8] INFO  b.s.d.executor - Loading executor $spoutcoord-spout0:[2 2]<br>8343 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks $spoutcoord-spout0:[2 2]<br>8346 [Thread-8] INFO  b.s.d.executor - Finished loading executor $spoutcoord-spout0:[2 2]<br>8355 [Thread-8] INFO  b.s.d.executor - Loading executor b-2:[7 7]<br>8372 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-2:[7 7]<br>8375 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-2:[7 7]<br>8381 [Thread-8] INFO  b.s.d.executor - Loading executor b-3:[22 22]<br>8401 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-3:[22 22]<br>8404 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-3:[22 22]<br>8412 [Thread-8] INFO  b.s.d.executor - Loading executor <strong>acker:[3 3]<br>8414 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks </strong>acker:[3 3]<br>8424 [Thread-8] INFO  b.s.d.executor - Timeouts disabled for executor <strong>acker:[3 3]<br>8425 [Thread-8] INFO  b.s.d.executor - Finished loading executor </strong>acker:[3 3]<br>8443 [Thread-8] INFO  b.s.d.executor - Loading executor b-5:[24 24]<br>8465 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-5:[24 24]<br>8467 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-5:[24 24]<br>8530 [Thread-8] INFO  b.s.d.executor - Loading executor $mastercoord-bg0:[1 1]<br>8539 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks $mastercoord-bg0:[1 1]<br>8576 [Thread-8] INFO  b.s.d.executor - Finished loading executor $mastercoord-bg0:[1 1]<br>8603 [Thread-8] INFO  b.s.d.executor - Loading executor b-2:[18 18]<br>8633 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-2:[18 18]<br>8635 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-2:[18 18]<br>8646 [Thread-8] INFO  b.s.d.executor - Loading executor b-2:[6 6]<br>8681 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-2:[6 6]<br>8683 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-2:[6 6]<br>8719 [Thread-8] INFO  b.s.d.executor - Loading executor b-2:[20 20]<br>8757 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-2:[20 20]<br>8763 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-2:[20 20]<br>8782 [Thread-8] INFO  b.s.d.executor - Loading executor b-2:[9 9]<br>8808 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-2:[9 9]<br>8818 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-2:[9 9]<br>8828 [Thread-8] INFO  b.s.d.executor - Loading executor b-4:[23 23]<br>8847 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-4:[23 23]<br>8851 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-4:[23 23]<br>8858 [refresh-active-timer] INFO  b.s.d.worker - All connections are ready for worker 49c35a73-7500-4ea4-aaa2-4b1c1f231fd4:1027 with id 9dd8aeac-1cd6-467a-a84c-2637d0825d99<br>8864 [Thread-8] INFO  b.s.d.executor - Loading executor b-2:[11 11]<br>8877 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-2:[11 11]<br>8879 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-2:[11 11]<br>8886 [Thread-8] INFO  b.s.d.executor - Loading executor <strong>system:[-1 -1]<br>8887 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks </strong>system:[-1 -1]<br>8890 [Thread-8] INFO  b.s.d.executor - Finished loading executor <strong>system:[-1 -1]<br>8914 [Thread-8] INFO  b.s.d.executor - Loading executor b-2:[16 16]<br>9052 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-2:[16 16]<br>9055 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-2:[16 16]<br>9070 [Thread-8] INFO  b.s.d.executor - Loading executor b-2:[13 13]<br>9081 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-2:[13 13]<br>9089 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-2:[13 13]<br>9116 [Thread-8] INFO  b.s.d.executor - Loading executor b-2:[19 19]<br>9129 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-2:[19 19]<br>9132 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-2:[19 19]<br>9148 [Thread-8] INFO  b.s.d.executor - Loading executor b-2:[21 21]<br>9160 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-2:[21 21]<br>9163 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-2:[21 21]<br>9178 [Thread-8] INFO  b.s.d.executor - Loading executor b-1:[5 5]<br>9192 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-1:[5 5]<br>9194 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-1:[5 5]<br>9204 [Thread-8] INFO  b.s.d.executor - Loading executor spout1:[26 26]<br>9205 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks spout1:[26 26]<br>9208 [Thread-8] INFO  b.s.d.executor - Finished loading executor spout1:[26 26]<br>9220 [Thread-8] INFO  b.s.d.executor - Loading executor b-2:[10 10]<br>9226 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-2:[10 10]<br>9228 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-2:[10 10]<br>9234 [Thread-8] INFO  b.s.d.executor - Loading executor b-2:[14 14]<br>9237 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-2:[14 14]<br>9239 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-2:[14 14]<br>9244 [Thread-8] INFO  b.s.d.executor - Loading executor b-0:[4 4]<br>9248 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-0:[4 4]<br>9249 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-0:[4 4]<br>9255 [Thread-8] INFO  b.s.d.executor - Loading executor b-2:[15 15]<br>9260 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-2:[15 15]<br>9261 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-2:[15 15]<br>9273 [Thread-8] INFO  b.s.d.executor - Loading executor spout0:[25 25]<br>9275 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks spout0:[25 25]<br>9277 [Thread-8] INFO  b.s.d.executor - Finished loading executor spout0:[25 25]<br>9284 [Thread-8] INFO  b.s.d.executor - Loading executor b-2:[17 17]<br>9289 [Thread-8] INFO  b.s.d.executor - Loaded executor tasks b-2:[17 17]<br>9291 [Thread-8] INFO  b.s.d.executor - Finished loading executor b-2:[17 17]<br>9298 [Thread-8] INFO  b.s.d.worker - Worker has topology config {“topology.builtin.metrics.bucket.size.secs” 60, ……<br>9298 [Thread-8] INFO  b.s.d.worker - Worker 9dd8aeac-1cd6-467a-a84c-2637d0825d99 for storm wordCounter-1-1468420782 on 49c35a73-7500-4ea4-aaa2-4b1c1f231fd4:1027 has finished loading<br>9298 [Thread-8] INFO  b.s.config - SET worker-user 9dd8aeac-1cd6-467a-a84c-2637d0825d99<br>9875 [Thread-27-b-2] INFO  b.s.d.executor - Preparing bolt b-2:(18)<br>9882 [Thread-35-b-4] INFO  b.s.d.executor - Preparing bolt b-4:(23)<br>9882 [Thread-41-b-2] INFO  b.s.d.executor - Preparing bolt b-2:(16)<br>9883 [Thread-13-b-2] INFO  b.s.d.executor - Preparing bolt b-2:(12)<br>9883 [Thread-59-b-2] INFO  b.s.d.executor - Preparing bolt b-2:(15)<br>9883 [Thread-47-b-2] INFO  b.s.d.executor - Preparing bolt b-2:(21)<br>9893 [Thread-35-b-4] INFO  b.s.d.executor - Prepared bolt b-4:(23)<br>9896 [Thread-47-b-2] INFO  b.s.d.executor - Prepared bolt b-2:(21)<br>9896 [Thread-59-b-2] INFO  b.s.d.executor - Prepared bolt b-2:(15)<br>9896 [Thread-27-b-2] INFO  b.s.d.executor - Prepared bolt b-2:(18)<br>9896 [Thread-13-b-2] INFO  b.s.d.executor - Prepared bolt b-2:(12)<br>9896 [Thread-41-b-2] INFO  b.s.d.executor - Prepared bolt b-2:(16)<br>9898 [Thread-31-b-2] INFO  b.s.d.executor - Preparing bolt b-2:(20)<br>9898 [Thread-15-$spoutcoord-spout0] INFO  b.s.d.executor - Preparing bolt $spoutcoord-spout0:(2)<br>9899 [Thread-61-spout0] INFO  b.s.d.executor - Preparing bolt spout0:(25)<br>9900 [Thread-15-$spoutcoord-spout0] INFO  b.s.u.StormBoundedExponentialBackoffRetry - The baseSleepTimeMs [1000] the maxSleepTimeMs [30000] the maxRetries [5]<br>9900 [Thread-61-spout0] INFO  b.s.d.executor - Prepared bolt spout0:(25)<br>9901 [Thread-15-$spoutcoord-spout0] INFO  o.a.c.f.i.CuratorFrameworkImpl - Starting<br>9901 [Thread-31-b-2] INFO  b.s.d.executor - Prepared bolt b-2:(20)<br>9907 [Thread-15-$spoutcoord-spout0-EventThread] INFO  o.a.c.f.s.ConnectionStateManager - State change: CONNECTED<br>9908 [Thread-43-b-2] INFO  b.s.d.executor - Preparing bolt b-2:(13)<br>9908 [Thread-37-b-2] INFO  b.s.d.executor - Preparing bolt b-2:(11)<br>9908 [Thread-63-b-2] INFO  b.s.d.executor - Preparing bolt b-2:(17)<br>9910 [Thread-43-b-2] INFO  b.s.d.executor - Prepared bolt b-2:(13)<br>9910 [Thread-37-b-2] INFO  b.s.d.executor - Prepared bolt b-2:(11)<br>9911 [Thread-63-b-2] INFO  b.s.d.executor - Prepared bolt b-2:(17)<br>9918 [Thread-49-b-1] INFO  b.s.d.executor - Preparing bolt b-1:(5)<br>9918 [Thread-39-</strong>system] INFO  b.s.d.executor - Preparing bolt <strong>system:(-1)<br>9918 [Thread-29-b-2] INFO  b.s.d.executor - Preparing bolt b-2:(6)<br>9920 [Thread-49-b-1] INFO  b.s.d.executor - Prepared bolt b-1:(5)<br>9920 [Thread-29-b-2] INFO  b.s.d.executor - Prepared bolt b-2:(6)<br>9921 [Thread-15-$spoutcoord-spout0] INFO  b.s.u.StormBoundedExponentialBackoffRetry - The baseSleepTimeMs [1000] the maxSleepTimeMs [30000] the maxRetries [5]<br>9922 [Thread-15-$spoutcoord-spout0] INFO  o.a.c.f.i.CuratorFrameworkImpl - Starting<br>9924 [Thread-39-</strong>system] INFO  b.s.d.executor - Prepared bolt <strong>system:(-1)<br>9929 [Thread-51-spout1] INFO  b.s.d.executor - Opening spout spout1:(26)<br>9929 [Thread-25-$mastercoord-bg0] INFO  b.s.d.executor - Opening spout $mastercoord-bg0:(1)<br>9929 [Thread-15-$spoutcoord-spout0-EventThread] INFO  o.a.c.f.s.ConnectionStateManager - State change: CONNECTED<br>9938 [Thread-51-spout1] INFO  b.s.d.executor - Opened spout spout1:(26)<br>9937 [Thread-25-$mastercoord-bg0] INFO  b.s.u.StormBoundedExponentialBackoffRetry - The baseSleepTimeMs [1000] the maxSleepTimeMs [30000] the maxRetries [5]<br>9940 [Thread-25-$mastercoord-bg0] INFO  o.a.c.f.i.CuratorFrameworkImpl - Starting<br>9940 [Thread-33-b-2] INFO  b.s.d.executor - Preparing bolt b-2:(9)<br>9942 [Thread-51-spout1] INFO  b.s.d.executor - Activating spout spout1:(26)<br>9942 [Thread-33-b-2] INFO  b.s.d.executor - Prepared bolt b-2:(9)<br>9947 [Thread-53-b-2] INFO  b.s.d.executor - Preparing bolt b-2:(10)<br>9950 [Thread-53-b-2] INFO  b.s.d.executor - Prepared bolt b-2:(10)<br>9956 [Thread-11-b-2] INFO  b.s.d.executor - Preparing bolt b-2:(8)<br>9956 [Thread-45-b-2] INFO  b.s.d.executor - Preparing bolt b-2:(19)<br>9957 [Thread-23-b-5] INFO  b.s.d.executor - Preparing bolt b-5:(24)<br>9958 [Thread-23-b-5] INFO  b.s.d.executor - Prepared bolt b-5:(24)<br>9958 [Thread-11-b-2] INFO  b.s.d.executor - Prepared bolt b-2:(8)<br>9958 [Thread-17-b-2] INFO  b.s.d.executor - Preparing bolt b-2:(7)<br>9959 [Thread-55-b-2] INFO  b.s.d.executor - Preparing bolt b-2:(14)<br>9959 [Thread-19-b-3] INFO  b.s.d.executor - Preparing bolt b-3:(22)<br>9960 [Thread-19-b-3] INFO  b.s.d.executor - Prepared bolt b-3:(22)<br>9960 [Thread-25-$mastercoord-bg0-EventThread] INFO  o.a.c.f.s.ConnectionStateManager - State change: CONNECTED<br>9960 [Thread-17-b-2] INFO  b.s.d.executor - Prepared bolt b-2:(7)<br>9962 [Thread-45-b-2] INFO  b.s.d.executor - Prepared bolt b-2:(19)<br>9963 [Thread-55-b-2] INFO  b.s.d.executor - Prepared bolt b-2:(14)<br>9964 [Thread-57-b-0] INFO  b.s.d.executor - Preparing bolt b-0:(4)<br>9964 [Thread-21-</strong>acker] INFO  b.s.d.executor - Preparing bolt <strong>acker:(3)<br>9965 [Thread-57-b-0] INFO  b.s.d.executor - Prepared bolt b-0:(4)<br>9966 [Thread-21-</strong>acker] INFO  b.s.d.executor - Prepared bolt __acker:(3)<br>9969 [Thread-15-$spoutcoord-spout0] INFO  b.s.d.executor - Prepared bolt $spoutcoord-spout0:(2)<br>9971 [Thread-25-$mastercoord-bg0] INFO  b.s.u.StormBoundedExponentialBackoffRetry - The baseSleepTimeMs [1000] the maxSleepTimeMs [30000] the maxRetries [5]<br>9972 [Thread-25-$mastercoord-bg0] INFO  o.a.c.f.i.CuratorFrameworkImpl - Starting<br>9984 [Thread-25-$mastercoord-bg0-EventThread] INFO  o.a.c.f.s.ConnectionStateManager - State change: CONNECTED<br>DRPC RESULT: [[0]]<br>9988 [Thread-25-$mastercoord-bg0] INFO  b.s.d.executor - Opened spout $mastercoord-bg0:(1)<br>9988 [Thread-25-$mastercoord-bg0] INFO  b.s.d.executor - Activating spout $mastercoord-bg0:(1)<br>DRPC RESULT: [[60]]<br>DRPC RESULT: [[120]]<br>DRPC RESULT: [[179]]<br>DRPC RESULT: [[239]]<br>DRPC RESULT: [[299]]<br>DRPC RESULT: [[359]]<br>DRPC RESULT: [[414]]<br>DRPC RESULT: [[474]]<br>DRPC RESULT: [[534]]<br>DRPC RESULT: [[593]]<br>DRPC RESULT: [[653]]<br>DRPC RESULT: [[713]]<br>DRPC RESULT: [[768]]</p>
<p>Process finished with exit code 130</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[kafka-0.10.0启动过程分析]]></title>
      <url>http://maohong.github.io/2016/07/08/kafka-0-10-0%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>kafka-0.10.0是官方出的最新稳定版本，提供了大量新的feature，具体可见<a href="http://www.iteblog.com/archives/1677" target="_blank" rel="external">这里</a>，本文主要分析kafka-0.10-0的源码结构和启动过程。</p>
<h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p>kafka-0.10.0的源码可以从github上fork一份，在源码目录下执行./gradlew idea生成idea项目，然后导入idea即可。这中间需要使用gradle进行依赖包的下载，导入后可以看到其源码结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20160708-kafka0.10.0%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/1.png" alt=""></p>
<p>包括几大重要模块：</p>
<ul>
<li>clients主要是kafka-client相关的代码，包括consumer、producer，还包括一些公共逻辑，如授权认证、序列化等。</li>
<li>connect主要是kafka-connect模块的代码逻辑，Kafka connect是0.9版本增加的特性,支持创建和管理数据流管道。通过它可以将大数据从其它系统导入到Kafka中，也可以从Kafka中导出到其它系统，比如数据库、elastic search等。</li>
<li>core模块是kafka的核心部分，主要包括broker的实现逻辑、producer和consumer的javaapi等。</li>
<li>streams模块主要是kafka-streaming的实现，提供了一整套描述常见流操作的高级语言API（比如 joining, filtering以及aggregation等），我们可以基于此开发流处理应用程序。</li>
</ul>
<a id="more"></a>
<h2 id="启动入口"><a href="#启动入口" class="headerlink" title="启动入口"></a>启动入口</h2><p>kafka的启动入口在core_main这个module下，入口函数如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">val</span> serverProps = getPropsFromArgs(args)</div><div class="line">      <span class="keyword">val</span> kafkaServerStartable = <span class="type">KafkaServerStartable</span>.fromProps(serverProps)</div><div class="line"></div><div class="line">      <span class="comment">// attach shutdown handler to catch control-c</span></div><div class="line">      <span class="type">Runtime</span>.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="type">Thread</span>() &#123;</div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() = &#123;</div><div class="line">          kafkaServerStartable.shutdown</div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">      kafkaServerStartable.startup</div><div class="line">      kafkaServerStartable.awaitShutdown</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> &#123;</div><div class="line">      <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt;</div><div class="line">        fatal(e)</div><div class="line">        <span class="type">System</span>.exit(<span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="type">System</span>.exit(<span class="number">0</span>)</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>先从命令行指定的配置文件加载配置，然后通过KafkaServerStartable类启动broker，实际上在KafkaServerStartable中维护了一个KafkaServer对象，它通过调用KafkaServer的startup方法启动broker。</p>
<h2 id="broker启动过程"><a href="#broker启动过程" class="headerlink" title="broker启动过程"></a>broker启动过程</h2><p>下面并启动过程代码按启动顺序分两部分做说明。</p>
<p>第一部分主要是核心模块的启动，代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">metrics = <span class="keyword">new</span> <span class="type">Metrics</span>(metricConfig, reporters, kafkaMetricsTime, <span class="literal">true</span>)</div><div class="line"></div><div class="line">        brokerState.newState(<span class="type">Starting</span>)</div><div class="line"></div><div class="line">        <span class="comment">/* start scheduler */</span></div><div class="line">        kafkaScheduler.startup()</div><div class="line"></div><div class="line">        <span class="comment">/* setup zookeeper */</span></div><div class="line">        zkUtils = initZk()</div><div class="line"></div><div class="line">        <span class="comment">/* start log manager */</span></div><div class="line">        logManager = createLogManager(zkUtils.zkClient, brokerState)</div><div class="line">        logManager.startup()</div><div class="line"></div><div class="line">        <span class="comment">/* generate brokerId */</span></div><div class="line">        config.brokerId =  getBrokerId</div><div class="line">        <span class="keyword">this</span>.logIdent = <span class="string">"[Kafka Server "</span> + config.brokerId + <span class="string">"], "</span></div><div class="line"></div><div class="line">        socketServer = <span class="keyword">new</span> <span class="type">SocketServer</span>(config, metrics, kafkaMetricsTime)</div><div class="line">        socketServer.startup()</div><div class="line"></div><div class="line">        <span class="comment">/* start replica manager */</span></div><div class="line">        replicaManager = <span class="keyword">new</span> <span class="type">ReplicaManager</span>(config, metrics, time, kafkaMetricsTime, zkUtils, kafkaScheduler, logManager,</div><div class="line">          isShuttingDown)</div><div class="line">        replicaManager.startup()</div><div class="line"></div><div class="line">        <span class="comment">/* start kafka controller */</span></div><div class="line">        kafkaController = <span class="keyword">new</span> <span class="type">KafkaController</span>(config, zkUtils, brokerState, kafkaMetricsTime, metrics, threadNamePrefix)</div><div class="line">        kafkaController.startup()</div><div class="line"></div><div class="line">        <span class="comment">/* start group coordinator */</span></div><div class="line">        groupCoordinator = <span class="type">GroupCoordinator</span>(config, zkUtils, replicaManager, kafkaMetricsTime)</div><div class="line">        groupCoordinator.startup()</div><div class="line"></div><div class="line">        <span class="comment">/* Get the authorizer and initialize it if one is specified.*/</span></div><div class="line">        authorizer = <span class="type">Option</span>(config.authorizerClassName).filter(_.nonEmpty).map &#123; authorizerClassName =&gt;</div><div class="line">          <span class="keyword">val</span> authZ = <span class="type">CoreUtils</span>.createObject[<span class="type">Authorizer</span>](authorizerClassName)</div><div class="line">          authZ.configure(config.originals())</div><div class="line">          authZ</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* start processing requests */</span></div><div class="line">        apis = <span class="keyword">new</span> <span class="type">KafkaApis</span>(socketServer.requestChannel, replicaManager, groupCoordinator,</div><div class="line">          kafkaController, zkUtils, config.brokerId, config, metadataCache, metrics, authorizer)</div><div class="line">        requestHandlerPool = <span class="keyword">new</span> <span class="type">KafkaRequestHandlerPool</span>(config.brokerId, socketServer.requestChannel, apis, config.numIoThreads)</div><div class="line">        brokerState.newState(<span class="type">RunningAsBroker</span>)</div></pre></td></tr></table></figure>
<ol>
<li>首先是初始化Metrics注册信息。</li>
<li>接着把当前broker的状态先置为Starting。</li>
<li>启动kafkaScheduler，其内部维护了一个ScheduledThreadPoolExecutor，用于执行broker内置的一些周期性运行的job或定时job。比如，启动自动提交时，broker会定期维护客户端的消费topic-partition的offset信息。</li>
<li>初始化zookeeper访问工具，建立必要的数据路径。</li>
<li>启动LogManager，也就是日志数据管理子系统，负责日志数据的创建、截断、滚动、和清理等。</li>
<li>启动SocketServer，一个基于NIO的socker服务端，其线程模型是有一个acceptor线程来接受客户端的连接，对应这个acceptor有N个processor线程，每个processor有自己的selector来从sockets读取收到的请求。另外，有M个handler线程专门处理请求并把处理结果返回给processor线程并通过socket写回给客户端。</li>
<li>启动ReplicaManager，也即副本管理器，用于管理每个topic-partition的副本状态，包括主从、ISR列表等。</li>
<li>启动KafkaController，可以理解为kafka集群的中央控制器，负责全局的协调，比如选取leader，reassignment等，其自身也支持动态选举高可用。</li>
<li>启动GroupCoordinator，主要用于broker组管理和offset管理。</li>
<li>初始化授权认证管理器，用户可以自己通过参数authorizer.class.name指定具体的Authorizer实现。kafka自带有SimpleAclAuthorizer的简单实现。</li>
<li>初始化KafkaApis，用于统一接收外部请求。</li>
<li>初始化KafkaRequestHandlerPool，内部是一个线程池，用于具体处理外部请求。</li>
<li>将当前broker的状态置为RunningAsBroker，这时，broker已经可以对外提供服务了。</li>
</ol>
<p>第二部分主要是辅助模块的启动，代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="type">Mx4jLoader</span>.maybeLoad()</div><div class="line"></div><div class="line"><span class="comment">/* start dynamic config manager */</span></div><div class="line">dynamicConfigHandlers = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">ConfigHandler</span>](<span class="type">ConfigType</span>.<span class="type">Topic</span> -&gt; <span class="keyword">new</span> <span class="type">TopicConfigHandler</span>(logManager, config),</div><div class="line">                                                   <span class="type">ConfigType</span>.<span class="type">Client</span> -&gt; <span class="keyword">new</span> <span class="type">ClientIdConfigHandler</span>(apis.quotaManagers))</div><div class="line"></div><div class="line"><span class="comment">// Apply all existing client configs to the ClientIdConfigHandler to bootstrap the overrides</span></div><div class="line"><span class="comment">// <span class="doctag">TODO:</span> Move this logic to DynamicConfigManager</span></div><div class="line"><span class="type">AdminUtils</span>.fetchAllEntityConfigs(zkUtils, <span class="type">ConfigType</span>.<span class="type">Client</span>).foreach &#123;</div><div class="line">  <span class="keyword">case</span> (clientId, properties) =&gt; dynamicConfigHandlers(<span class="type">ConfigType</span>.<span class="type">Client</span>).processConfigChanges(clientId, properties)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Create the config manager. start listening to notifications</span></div><div class="line">dynamicConfigManager = <span class="keyword">new</span> <span class="type">DynamicConfigManager</span>(zkUtils, dynamicConfigHandlers)</div><div class="line">dynamicConfigManager.startup()</div><div class="line"></div><div class="line"><span class="comment">/* tell everyone we are alive */</span></div><div class="line"><span class="keyword">val</span> listeners = config.advertisedListeners.map &#123;<span class="keyword">case</span>(protocol, endpoint) =&gt;</div><div class="line">  <span class="keyword">if</span> (endpoint.port == <span class="number">0</span>)</div><div class="line">    (protocol, <span class="type">EndPoint</span>(endpoint.host, socketServer.boundPort(protocol), endpoint.protocolType))</div><div class="line">  <span class="keyword">else</span></div><div class="line">    (protocol, endpoint)</div><div class="line">&#125;</div><div class="line">kafkaHealthcheck = <span class="keyword">new</span> <span class="type">KafkaHealthcheck</span>(config.brokerId, listeners, zkUtils, config.rack,</div><div class="line">  config.interBrokerProtocolVersion)</div><div class="line">kafkaHealthcheck.startup()</div><div class="line"></div><div class="line"><span class="comment">// Now that the broker id is successfully registered via KafkaHealthcheck, checkpoint it</span></div><div class="line">checkpointBrokerId(config.brokerId)</div><div class="line"></div><div class="line"><span class="comment">/* register broker metrics */</span></div><div class="line">registerStats()</div><div class="line"></div><div class="line">shutdownLatch = <span class="keyword">new</span> <span class="type">CountDownLatch</span>(<span class="number">1</span>)</div><div class="line">startupComplete.set(<span class="literal">true</span>)</div><div class="line">isStartingUp.set(<span class="literal">false</span>)</div><div class="line"><span class="type">AppInfoParser</span>.registerAppInfo(jmxPrefix, config.brokerId.toString)</div><div class="line">info(<span class="string">"started"</span>)</div></pre></td></tr></table></figure>
<ol>
<li>启动jmx，通过参数kafka_mx4jenable控制是否启用jmx，默认为false。</li>
<li>初始化TopicConfigHandler和ClientIdConfigHandler，前者用于处理zk上的topic配置变更信息，后者用于zk上的clientId配置变更信息。</li>
<li>启动DynamicConfigManager，通过动态配置管理器，监听zk上的配置节点变化，并根据具体变化的配置信息调用TopicConfigHandler或ClientIdConfigHandler更新配置。</li>
<li>启动KafkaHealthcheck，用于在zk上注册当前broker节点信息，以便节点退出时其他broker和consumer能监听到，目前的节点健康度判断比较简单，只是单纯的看zk上的节点是否存在。</li>
<li>最后，在本地对当前broker做个checkpoint，并注册jmx bean信息</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Storm的消息可靠处理机制]]></title>
      <url>http://maohong.github.io/2015/11/05/Storm%E7%9A%84%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>提交进入Storm运行的topology实际上是一个有向无环图（DAG），其中的节点是由spout和bolt组成，边则可以理解为消息从一个节点到传输到另一个节点的过程。对于spout产生的tuple，只有在topology上处理完毕后，才认为这个tuple被storm可靠处理。</p>
<p>Storm提供了可靠处理消息（storm中的通用名叫tuple）的框架，我们在写一个topology程序时，若需要保证spout产生的消息的可靠处理，需要做到两点：</p>
<p>第一是spout/bolt每生成一个新的tuple都告诉storm一下（其中spout发出的tuple有个id叫rootId），从而让storm能够追踪rootId和每个衍生tuple的处理状态。</p>
<p>第二是每个tuple被下游bolt处理完毕后，无论处理成功或失败，也再告诉storm一下，从而让storm知道是否需要spout重新发送rootId。</p>
<p>做了这两件事，storm就能知道这个tuple是否被处理完毕。如果是处理成功了的，就说明最初从spout发出的tuple（rootId）已在topology中处理完毕，无需spout重新发送。如果是处理失败的，storm则会告知spout重新发送rootId这个tuple。</p>
<h2 id="在程序中实现消息可靠处理"><a href="#在程序中实现消息可靠处理" class="headerlink" title="在程序中实现消息可靠处理"></a>在程序中实现消息可靠处理</h2><p>那在写一个topology时，我们该如何做上面提到的两件事呢？<br><a id="more"></a><br>Storm提供了BaseRichBolt抽象类（实现了IRichBolt接口），一个示例bolt如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitSentence</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</div><div class="line">    OutputCollector _collector;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf, TopologyContext context, OutputCollector collector)</span> </span>&#123;</div><div class="line">        _collector = collector;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple t)</span> </span>&#123;</div><div class="line">        String sentence = t.getString(<span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span>(String word: sentence.split(<span class="string">" "</span>)) &#123;</div><div class="line">            <span class="comment">//1. 告诉storm生成了一个新的tuple，并且这个tuple的锚点是tuple</span></div><div class="line">            _collector.emit(t, <span class="keyword">new</span> Values(word));</div><div class="line">        &#125;</div><div class="line">        _collector.ack(t); <span class="comment">//2. 告诉storm，t这个tuple已处理完毕</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</div><div class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码就做了这两件事，一是输出新的tuple并告知storm，二是对当前tuple t处理完毕后，告知storm。</p>
<p>对于第一件事，这里要注意的是，在BaseRichBolt中输出一个新的tuple（示例中是word）时，必须指定其锚点（即当前bolt正在处理的tuple），因为输出新的tuple会继续被下游bolt处理，这个锚点tuple和下游tuple之间的路径就是DAG的一条边。如果不指定锚点，则可以理解为storm不知道这条边的存在，也就不会对新输出的tuple进行跟踪了。</p>
<p>如果我们确实不需要保证消息的可靠处理，则使用以下方式输出新tuple即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_collector.emit(<span class="keyword">new</span> Values(word));</div></pre></td></tr></table></figure>
<p>另外，一个tuple的锚点tuple可以有多个，比如如下代码，新输出的tuple的锚点就是tuple1和tuple2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List anchors = <span class="keyword">new</span> ArrayList();</div><div class="line">anchors.add(tuple1);</div><div class="line">anchors.add(tuple2);</div><div class="line">_collector.emit(anchors, <span class="keyword">new</span> Values(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</div></pre></td></tr></table></figure>
<p>对于第二件事，通过调用OutputCollector的ack或fail方法，即可告知storm当前tuple的处理结果。比如，假设我们在bolt中做一些操作的时候出现异常（比如访问redis、DB、hdfs等），可以调fail方法快速重放rootId，避免等到storm判断这个tuple处理超时后才重放。</p>
<h2 id="更简便的方式"><a href="#更简便的方式" class="headerlink" title="更简便的方式"></a>更简便的方式</h2><p>很明显，以上方式有几个弊端：</p>
<ol>
<li><p>输出新tuple和对tuple的ack/fail操作需要我们自己维护，代价很高，容易遗忘。</p>
</li>
<li><p>storm是在内存中维护每个tuple的处理状态，如果只对tuple进行锚点标记但处理完毕后忘记ack/fail，在tuple量非常大时，有内存溢出的风险。</p>
</li>
</ol>
<p>鉴于此，storm提供了BaseBasicBolt抽象类（实现了IBasicBolt接口）来帮助我们实现对每个tuple的锚点标记和ack/fail。<br>前面的例子可改写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitSentence</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple, BasicOutputCollector collector)</span> </span>&#123;</div><div class="line">        String sentence = tuple.getString(<span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span>(String word: sentence.split(<span class="string">" "</span>)) &#123;</div><div class="line">            collector.emit(<span class="keyword">new</span> Values(word));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</div><div class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见，在代码中，我们只需要关心bolt的处理逻辑即可，至于标记锚点和ack/fail，均不用关心。</p>
<p>细究一下storm框架对IBasicBolt的处理可知，在创建topology时，IBasicBolt是被封装在BasicBoltExecutor类（实现了IRichBolt接口）中处理的。</p>
<p>构建topology时的setBolt方法：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20151105/bolt-executor.png" alt=""></p>
<h2 id="原理-amp-示例"><a href="#原理-amp-示例" class="headerlink" title="原理&amp;示例"></a>原理&amp;示例</h2><p>刚刚提到对每个topology，storm都在内存中维护其tuple的处理状态，那么对于一个大规模集群，storm是如何高效的维护大量tuple的处理状态的呢？</p>
<p>其实，topology在运行时，内部有一组特殊的任务叫acker，专门用来做tuple的ack/fail。当一个root tuple（spout输出的tuple）在DAG中处理完毕后，acker会向产生该tuple的spout发送消息来ack这个tuple。</p>
<p>我们可通过参数Config.TOPOLOGY_ACKER_EXECUTORS指定topology中的acker任务的数量，默认是与topology中的worker数相同，在处理大量消息的场景下，可以通过此参数增加topology的acker任务数，以提高对message做ack/fail的效率。</p>
<p>storm通过给每个tuple设置一个全局唯一id，并在输出tuple和tuple处理完毕时收集tuple的id，并进行异或运算，巧妙的实现tuple状态的维护。先看下图示例：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20151105/storm-ack.png" alt=""></p>
<p>在这个topology其中包含一个spout，3个bolt和一个acker bolt，紫色线表示tuple的流向，绿色线表示每个bolt处理完tuple后的ack/fail调用，红色线表示acker回调spout的ack/fail方法来标记root tuple处理完毕。</p>
<p>以下是storm的ack框架对tuple的处理状态维护过程说明：</p>
<p>第(1)(2)步，spout发送T1到bolt1，发送T2到bolt2，T1和T2具有相同的内容（可以认为都把spout的输出作为自己的输入）。每条消息都会有一个全局唯一id，T1的锚点为<rootid,t1>，T2的锚点为<rootid,t2>。</rootid,t2></rootid,t1></p>
<p>第(3)步，spout发送完毕T1、T2后，在acker中注册一条记录rootId=T1^T2。</p>
<p>第(4)(5)步，bolt1收到T1处理完毕后对T1进行ack并发送T3,T4到bolt3，所以在acker中注册T1,T3,T4，acker中的跟踪项变为rootId=T1^T2^T1^T3^T4=T2^T3^T4</p>
<p>第(6)(7)步，bolt2收到T2处理完毕后对T2进行ack并发送T5,T6,T7到bolt4，所以在acker中注册T2,T5,T6,T7，acker中的跟踪项变为rootId=T2^T3^T4^T2^T5^T6^T7=T3^T4^T5^T6^T7</p>
<p>第(8)步，bolt3收到T3,T4处理完毕后对T3,T4进行ack，没有输出新的tuple，所以在acker中注册T3,T4，acker中的跟踪项变为rootId=T3^T4^T5^T6^T7^T3^T4=T5^T6^T7</p>
<p>第(9)步，bolt4收到T5,T6,T7处理完毕后对T5,T6,T7进行ack，没有输出新的tuple，所以在acker中注册T5,T6,T7，acker中的跟踪项变为rootId=T5^T6^T7^T5^T6^T7=0</p>
<p>第(10)步，acker bolt发现rootId对应的追踪值为0，说明该rootId对应的源消息以及衍生出来的所有消息（bolt1,bolt2新输出的消息）都被成功处理完毕。于是acker bolt会回调spout的ack方法，标识消息rootId已被topology处理成功。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spark on yarn的内存分配问题]]></title>
      <url>http://maohong.github.io/2015/08/11/Spark-on-yarn%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在测试spark on yarn时，发现一些内存分配上的问题，具体如下。</p>
<p>在$SPARK_HOME/conf/spark-env.sh中配置如下参数：</p>
<blockquote>
<p>SPARK_EXECUTOR_INSTANCES=4            <em>在yarn集群中启动的executor进程数</em></p>
<p>SPARK_EXECUTOR_MEMORY=2G              <em>为每个executor进程分配的内存大小</em></p>
<p>SPARK_DRIVER_MEMORY=1G                <em>为spark-driver进程分配的内存大小</em></p>
</blockquote>
<p>执行$SPARK_HOME/bin/spark-sql –master yarn，按yarn-client模式启动spark-sql交互命令行（即driver程序运行在本地，而非yarn的container中），日志显示的关于AppMaster和Executor的内存信息如下：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150813/sparkonyarn-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150813/sparkonyarn-2.png" alt=""></p>
<p>日志显示，AppMaster的内存是896MB，其中包含了384MB的memoryOverhead；启动了5个executor，第一个的可用内存是530.3MB，其余每个Executor的可用内存是1060.3MB。</p>
<p>到yarnUI看下资源使用情况，共启动了5个container，占用内存13G，其中一台NodeManager启动了2个container，占用内存4G（1个AppMaster占1G、另一个占3G），另外3台各启了1个container，每个占用3G内存。</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150813/sparkonyarn-3.png" alt=""></p>
<p>再到sparkUI看下executors的情况，这里有5个executor，其中driver是运行在执行spark-sql命令的本地服务器上，另外4个是运行在yarn集群中。Driver的可用storage memory为530.3MB，另外4个都是1060.3MB（与日志信息一致）。</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150813/sparkonyarn-4.png" alt=""></p>
<p>那么问题来了：</p>
<ol>
<li><p>Yarn为container分配的最小内存由yarn.scheduler.minimum-allocation-mb参数决定，默认是1G，从yarnUI中看确实如此，可为何spark的日志里显示AppMaster的实际内存是896-384=512MB呢？384MB是怎么算出来的？</p>
</li>
<li><p>spark配置文件里指定了每个executor的内存为2G，为何日志和sparkUI上显示的是1060.3MB？</p>
</li>
<li><p>driver的内存配置为1G，为何sparkUI里显示的是530.3MB呢？</p>
</li>
<li><p>为何yarn中每个container分配的内存是3G，而不是executor需要的2G呢？</p>
</li>
</ol>
<h2 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h2><p>进过一番调研，发现这里有些概念容易混淆，整理如下，序号对应上面的问题：<br><a id="more"></a><br>(1) spark的yarn-client向ResourceManager申请提交作业/启动AppMaster时，会判断是否是集群模式，如果是集群模式，则AppMaster的内存大小与driver内存大小一致，否则由spark.yarn.am.memory决定，这个参数的默认值是512MB。我们使用的是yarn-client模式，所以实际内存是512MB。</p>
<p><font color="red">384MB是spark-client为appMaster额外申请的内存</font>，计算方法如下：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150813/sparkonyarn-5.png" alt=""></p>
<p>即，默认从参数读取（集群模式从spark.yarn.driver.memoryOverhead参数读，否则从spark.yarn.am.memoryOverhead参数读），若没配此参数，则从AppMaster的内存*一定系数和默认最小overhead中取较大值。</p>
<p>在spark-1.4.1版本中，MEMORY_OVERHEAD_FACTOR的默认值为0.10（之前是0.07），MEMORY_OVERHEAD_MIN默认为384，我们没有指定spark.yarn.driver.memoryOverhead和spark.yarn.am.memoryOverhead，而amMemory=512M（由spark.yarn.am.memory决定），因此memoryOverhead为max(512*0.10, 384)=384MB。</p>
<p>Executor的memoryOverhead计算方法与此一样，只是不区分是否集群模式，都默认由spark.yarn.executor.memoryOverhead配置。</p>
<p>(2) <font color="red">日志和sparkUI上显示的是executor内部用于缓存计算结果的内存空间，并不是executor所拥有的全部内存</font>。这部分内存是由以下公式计算：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150813/sparkonyarn-6.png" alt=""></p>
<p>Runtime.getRuntime.maxMemory按2048MB算，storage memory大小为1105.92MB，sparkUI显示的略小于此值，是正常的。</p>
<p>(3) 与上述第2点一样，storage memory的大小略小于1024<em>0.9</em>0.6=552.96MB</p>
<p>(4) 前面提到spark会为container额外申请一部分内存（memoryOverhead），因此，实际为container提交申请的内存大小是2048 + max(2048*0.10, 384) = 2432MB，而<font color="red">yarn在做资源分配时会做资源规整化，即应用程序申请的资源量一定是最小可申请资源量的整数倍（向上取整）</font>，最小可申请内存量由yarn.scheduler.minimum-allocation-mb指定，因此，会为container分配3G内存。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>为了验证上述规则，继续修改配置参数：</p>
<blockquote>
<p>SPARK_EXECUTOR_INSTANCES=4          <em>在yarn集群中启动的executor进程数</em></p>
<p>SPARK_EXECUTOR_MEMORY=4G            <em>为每个executor进程分配的内存大小</em></p>
<p>SPARK_DRIVER_MEMORY=3G              <em>为spark-driver进程分配的内存大小</em></p>
</blockquote>
<p>并在启动spark-sql时指定spark.yarn.am.memory参数：</p>
<p><strong>bin/spark-sql –master yarn –conf spark.yarn.am.memory=1024m</strong></p>
<p>再看日志信息：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150813/sparkonyarn-7.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150813/sparkonyarn-8.png" alt=""></p>
<p>yarnUI状态：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150813/sparkonyarn-9.png" alt=""></p>
<p>sparkUI的executors信息：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150813/sparkonyarn-10.png" alt=""></p>
<p>可见，AppMaster的实际内存为1024M（1408-384），而其在yarn中的container内存大小为2G（1408大于1G，yarn按资源规整化原则为其分配2G）。</p>
<p>同理，driver的storage memory空间为3G*0.9*0.6=1.62G，executor的storage memory空间为4G*0.9*0.6=2.16G，executor所在container占用5G内存（4096+max(4096*0.10,384)= 4505.6，大于4G， yarn按资源规整化原则为其分配5G）。</p>
<p>Yarn集群的内存总占用空间为2+5*4=22G。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[storm集群supervisor节点异常退出问题排查]]></title>
      <url>http://maohong.github.io/2015/07/03/storm%E9%9B%86%E7%BE%A4supervisor%E8%8A%82%E7%82%B9%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
      <content type="html"><![CDATA[<h2 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h2><p>测试storm集群为0.9.4版本，前段时间出现supervisor进程挂掉，而其上work进程仍然运行的诡异情况，通过日志看到supervisor进程挂掉之前出现以下异常：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150701/1.png" alt=""></p>
<h2 id="问题排查过程"><a href="#问题排查过程" class="headerlink" title="问题排查过程"></a>问题排查过程</h2><p>很明显，是commons-io包的FileUtils工具类抛出的异常，原因是在调用commons-io包的FileUtils工具类做move directory操作时，目的文件夹已存在。</p>
<p>查看调用代码（supervisor.clj的第374行），是调用download-storm-code方法从nimbus下载topology的代码，并且download-storm-code方法中做代码下载前加了锁避免并发写文件。</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150701/2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150701/3.png" alt=""></p>
<p>果然，这里没有判断stormroot文件夹是否已存在，是个bug，具体可见这个issue：<a href="https://issues.apache.org/jira/browse/STORM-805" target="_blank" rel="external">https://issues.apache.org/jira/browse/STORM-805</a>。</p>
<p>这个问题在0.9.5版本中随着STORM-130一起修复了，代码如下：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150701/4.png" alt=""></p>
<p>但这里有三个问题：</p>
<ol>
<li><p>在调用download-storm-code方法前，代码中已做判断是否已下载topology代码，若已下载就不会调用download-storm-code方法了。为何进入这个方法后，做move directory操作时，代码却已经下载好了呢？</p>
</li>
<li><p>storm的历史发布版本有很多，为何0.9.4版本里会出现这个不该出现的问题，0.9.4相对老的版本是不是做了什么修改？</p>
</li>
<li><p>为何抛出异常后，supervisor进程就这么直接退出了？太弱了吧。。</p>
<a id="more"></a>
<p>继续看0.9.4的源码发现，<strong>supervisor中有以下两个事件线程，都会调用download-storm-code方法</strong>：</p>
</li>
</ol>
<p><strong>一个是synchronize-supervisor，用于同步nimbus任务</strong>，每隔10秒执行一次，会调用mk-synchronize-supervisor方法，以及时获取nimbus分配给该supervisor的新任务并移除已分配但不再需要执行的任务。</p>
<p><strong>另一个是sync-processes，用于根据任务变化同步管理worker进程</strong>，执行周期由SUPERVISOR-MONITOR-FREQUENCY-SECS（默认3秒）指定，会调用sync-processes方法，以关闭当前不处于valid状态的worker和启动新分配给该supervisor的worker。</p>
<p>其中，mk-synchronize-supervisor方法和sync-processes方法都会调用download-storm-code方法。</p>
<p>两个事件线程的定义：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150701/5.png" alt=""></p>
<p>mk-synchronize-supervisor方法调用download-storm-code方法：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150701/6.png" alt=""></p>
<p>sync-processes调用download-storm-code方法：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150701/7.png" alt=""></p>
<p>mk-synchronize-supervisor方法和sync-processes方法在调用前都会判断topology代码是否已下载，所以，出现上述异常的原因很可能是两个线程再调用download-storm-code方法时不同步引起的，即同时判断到需要下载topology代码并进入了download-storm-code方法，从而产生两次move directory的操作引发异常。</p>
<p>虽然download-storm-code方法内部通过加锁控制了写文件时的并发，但对进入download-storm-code方法并没有做好同步。</p>
<p>再回过头看0.9.5版本的代码，虽然在move directory前判断了目的文件夹是否存在以避免问题，但实际上还是存在两个线程同时进入download-storm-code方法的问题。</p>
<p>最后再比较了下0.9.3和0.9.4的代码（supervisor.clj），发现0.9.4的sync-processes方法中调用download-storm-code的逻辑是新加进去的，也就是说这个bug是0.9.4新引入的，以前的版本不会存在这个问题。</p>
<p>左边为0.9.3，右边为0.9.4：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150701/8.png" alt=""></p>
<p>关于第3个问题，再回看定义synchronize-supervisor事件线程的代码，是通过事件管理器event-manager来实现的，查看event.clj中的实现，event-manager会从一个LinkedBlockingQueue取出新事件并启动线程处理，线程若抛出非Interrupted异常，则直接退出进程了。</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150701/9.png" alt=""></p>
<p>至此，问题分析完毕。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[交换空间使用率过高问题分析]]></title>
      <url>http://maohong.github.io/2015/06/22/%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>线上两台java后台服务每次上线后再过段时间，就出现swap空间使用率较高的现象，而jvm内存使用和垃圾回收情况则很正常。相关图表如下：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150622%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98/1.png" alt=""></p>
<p>图中，每次上线后过一段时间，swap空间使用量会出现一个陡增，并随时间推移逐渐增加，期间会出现小幅度下降。</p>
<p>首先，从操作系统层面分析，swap空间使用较高，说明是系统物理内存不够用从而发生内存页交换，将部分内存数据搬至虚拟内存空间，也就是swap空间。但究竟是什么原因引起物理内存不足呢？因为Jvm堆大小是固定的，所以推断是因堆外内存占用空间较大引起。</p>
<p>于是，使用jmap -histo:live <pid>把进程中的对象信息dump出来，dump信息如下：</pid></p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150622%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98/2.png" alt=""></p>
<p>确实发现存在大量DirectByteBuffer对象，这说明内存中确实有大量引用了堆外内存的对象没有被回收！</p>
<p>同时，内存中也对应存在着大量的sun.misc.Cleaner和java.nio.DirectByteBuffer$Deallocator对象。这两个类是用于回收堆外内存的。Cleaner对象是在DirectByteBuffer的构造函数中创建，其中封装了回收堆外内存的逻辑，Cleaner执行clean资源的操作是通过启动Deallocator线程实现的，这个线程把DirectByteBuffer对象引用的堆外内存做回收。</p>
<p> 那么问题来了：</p>
<ol>
<li><p>为什么DirectByteBuffer对象没有被回收？</p>
</li>
<li><p>怎么做才能让DirectByteBuffer对象能被及时回收？</p>
</li>
</ol>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><a id="more"></a>
<p>先看了下启动jvm参数为-Xmn8192M -Xms13312M -Xmx13312M -XX:PermSize=512m -XX:MaxPermSize=512m，很明显，新生代空间配的太大，同时，也没有指定堆外内存的最大空间（-XX:MaxDirectMemorySize），这个参数没设置则默认等于-Xmx，然而服务器总内存只有16G，所以时间长了很可能会发生堆外内存溢出！</p>
<p>因为此服务是kafka集群的消费者，每天接收的报文量在1亿以上，这个过程中产生了大量的DirectByteBuffer对象，这些对象直接引用堆外内存，而同时，这些临时对象也会被回收，由于新生代空间配的很大，触发minor GC的频率不够高，从而不能及时释放已被占用的堆外内存，随着时间的推移，进程启动过一段时间后，堆外内存占用越来越多，最终被OS交换到swap空间。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>调整jvm参数，减少新生代大小为jvm堆空间的3/8，并指定堆外内存大小，调整后的jvm参数为-Xmn3840M -Xms10240M -Xmx10240M -XX:PermSize=512m -XX:MaxPermSize=512m -XX:MaxDirectMemorySize=4096m</p>
<p>调整后，swap空间占用情况有所好转，但依然占用2G左右！如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150622%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98/3.png" alt=""></p>
<p>4月21日调整参数重启服务后，在相当长的一段时间内，swap空间占用率极低，但在5月2日又出现swap空间使用率上升的情况。继续看了下jvm堆空间使用情况和full gc情况，如下：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150622%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98/4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150622%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98/5.png" alt=""></p>
<p>结合上面两张图，可见young gc较多，jvm堆空间整体使用率稳步上升，在5月2日与5月8日发生了两次full gc，并且每次发生fullgc后，jvm堆空间使用率下降较多，swap空间使用量只有小范围下降。这说明有一部分DirectByteBuffer对象在fullgc阶段做了回收，但依然有很多DirectByteBuffer对象没有被回收，仍然占用着堆外内存。</p>
<p>选择一台机器，继续减小其堆空间，jvm参数为-Xmn2048M -Xms6144M -Xmx6144M -XX:PermSize=512m -XX:MaxPermSize=512m -XX:MaxDirectMemorySize=4096m，经过一段时间观察，交换空间使用率很低，应该没再发生内存页交换了，同时gc频率变高，jvm堆空间的使用率在正常范围，说明DirectByteBuffer对象被更及时的回收了。</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150622%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98/6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150622%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98/7.png" alt=""></p>
<font color="red">由此可见，swap空间占用率高的原因主要还是JVM堆空间太高导致的堆外内存回收不及时。</font>

<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>看了下kafka-client的源码，接受消息时使用的是ByteBuffer，并没有使用DirectByteBuffer，所以很奇怪，这些大量的DirectByteBuffer对象是从哪生成的？哪里用到的？</p>
<p>运行命令jmap -dump:live,format=b,file=/data/server.dump <pid>，dump出内存快照，并用eclipse mat分析后，发现是zkclient中的一个地方用的，由于dump出的这个快照是问题解决后的内存快照，所以并不能说明问题，如果要找到根本原因，还是需要复现swap空间过高的场景，再做内存快照的dump。</pid></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hadoop-yarn中ResourceManager的服务模块]]></title>
      <url>http://maohong.github.io/2015/06/06/hadoop-yarn%E4%B8%ADResourceManager%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h2 id="Yarn简述"><a href="#Yarn简述" class="headerlink" title="Yarn简述"></a>Yarn简述</h2><p>Hadoop2.0引入了yarn（Yet Another Resource Negotiator）资源管理框架。1.0中的MapReduce计算框架变为运行在yarn上的一种application。</p>
<p>Yarn依然采用了master/slave结构，master是ResourceManager，负责整个集群的资源管理和调度，并且支持HA，slave是NodeManager，负责管理各子节点上的资源和任务。每个MapReduce作业提交给ResourceManager并被接受后，ResourceManager会通知某个NodeManager启动一个ApplicationMaster管理此作业的生命周期。</p>
<h2 id="ResourceManager中的模块划分"><a href="#ResourceManager中的模块划分" class="headerlink" title="ResourceManager中的模块划分"></a>ResourceManager中的模块划分</h2><p>Yarn中的大多数服务都是带状态的service实现，并通过事件驱动机制实现服务的状态转换和服务之间的交互。ResourceManager是yarn的核心组件，与NodeManager、ApplicationMaster、Client都有交互，提供了非常多的功能，下面基于hadoop2.7版本的实现，梳理一下ResourceManager中的重要service组件及其功能。</p>
<p>ResourceManager中按功能划分的service模块如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150606ResourceManager%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9D%97/1.png" alt=""></p>
<p>ResourceManager中核心模块主要包括客户端交互模块、NodeManager管理模块、ApplicationMaster管理模块、Application管理模块、安全管理模块、以及资源管理模块（调度、预留）等。</p>
<h2 id="各模块中的服务介绍"><a href="#各模块中的服务介绍" class="headerlink" title="各模块中的服务介绍"></a>各模块中的服务介绍</h2><p><strong>客户端交互模块：</strong></p>
<ul>
<li><p>AdminService</p>
<ul>
<li>管理员可通过此接口管理集群，如更新节点、更新ACL、更新队列等。内部有个EmbeddedElectorService，如果RM启用了自动HA，则通过这个service做leader election。</li>
</ul>
</li>
<li><p>ClientRMService</p>
<ul>
<li>负责为客户端提供服务，是ApplicationClientProtocol协议的服务端。负责处理来自客户端的RPC请求，包括提交app、查询app运行状态、终止app等。</li>
</ul>
</li>
<li><p>Webapp</p>
<ul>
<li>提供web页面服务，展示集群状态和资源使用情况。</li>
</ul>
</li>
</ul>
<p><strong>NodeManager管理模块</strong></p>
<ul>
<li><p>NMLivelinessMonitor</p>
<ul>
<li>用于监控NM是否存活，若NM在一定时间内（默认10分钟）未上报心跳，则认为其挂了。</li>
</ul>
</li>
<li><p>NodesListManager</p>
<ul>
<li>负责维护节点列表，并动态加载白名单（yarn.resourcemanager.nodes.include-path）和黑名单（yarn.resourcemanager.nodes.exlude-path）节点。</li>
</ul>
</li>
<li><p>RMNodeLabelsManager</p>
<ul>
<li>负责节点的标签管理。</li>
</ul>
</li>
<li><p>ResourceTrackerService</p>
<ul>
<li>负责与NodeManager通信，处理来自NodeManager的请求，包括注册NodeManager和节点心跳两种。接口定义在ResourceTracker中。</li>
</ul>
</li>
</ul>
<p><strong>ApplicationMaster管理模块</strong></p>
<ul>
<li><p>AMLivelinessMonitor：两个实例</p>
<ul>
<li>用于监控ApplicationMaster是否正常，如果在指定时间内（默认10分钟）未收到AM的心跳，则认为其死掉了。</li>
</ul>
</li>
<li><p>ApplicationMasterLauncher</p>
<ul>
<li>负责通知某个NodeManager启动或销毁ApplicationMaster。在app请求被接受后，与某个NodeManager通信，告知其为此app启动相应的ApplicationMaster。若app运行结束或被kill，则通知app所在NodeManager销毁ApplicationMaster。其内部也维护了一个阻塞队列，并有一个后台线程异步处理提交进来的启动ApplicationMaster的请求。</li>
</ul>
</li>
<li><p>ApplicationMasterService</p>
<ul>
<li>负责与ApplicationMaster通信，是ApplicationMasterProtocol协议的服务端，ApplicationMaster在NodeManager上启动后通过此协议向ResourceManager注册自己，运行过程中向ResourceManager发送心跳，以及app运行结束后告知RM自己所在的container可以被释放了。</li>
</ul>
</li>
</ul>
<p><strong>Application管理模块</strong></p>
<ul>
<li><p>RMAppManager</p>
<ul>
<li>ResourceManager接受客户端提交的app后，会通过RMAppManager来触发启动app的事件RMAppEventType.START，具体启动app的工作由RMAppImpl实现。</li>
</ul>
</li>
<li><p>ApplicationACLsManager</p>
<ul>
<li>负责app权限控制，包括查看和修改权限。</li>
</ul>
</li>
<li><p>ContainerAllocationExpirer</p>
<ul>
<li>用于监听NodeManager上是否正常启动了分配给ApplicationMaster的container，若在指定时间未启动（默认10分钟），ResourceManager会强制回收该container。</li>
</ul>
</li>
<li><p>RMApplicationHistoryWriter</p>
<ul>
<li>负责异步持久化Application运行中的相关日志，主要是Container、Application、ApplicationAttempt在启动和结束时的日志信息。</li>
</ul>
</li>
</ul>
<p><strong>安全管理模块</strong></p>
<ul>
<li>RMSecretManagerService<ul>
<li>负责管理各种通信密钥，包括：<ul>
<li>RM与NM通信的NMTokenSecretManagerInRM</li>
<li>RM与container通信的RMContainerTokenSecretManager</li>
<li>客户端与AM通信的ClientToAMTokenSecretManagerInRM</li>
<li>AM与RM通信的AMRMTokenSecretManager</li>
<li>DelegationTokenRenewer</li>
<li>启用了安全时，负责定时更新认证token。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>资源管理模块</strong></p>
<ul>
<li><p>ResourceScheduler</p>
<ul>
<li>资源调度器，可通过yarn.resourcemanager.scheduler.class指定，ResourceManager默认使用的是org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.CapacityScheduler。</li>
</ul>
</li>
<li><p>SchedulerEventDispatcher</p>
<ul>
<li>用于处理SchedulerEventType类型的事件，其内部维护了一个存储SchedulerEvent的阻塞队列，并由一个后台线程从队列中取出资源请求事件，再调用ResourceScheduler进行处理。</li>
</ul>
</li>
<li><p>ReservationSystem</p>
<ul>
<li>资源预留系统，对应的实现有CapacityReservationSystem和FairReservationSystem。</li>
</ul>
</li>
</ul>
<p>此外，SystemMetricsPublisher负责发布RM的系统统计信息。AsyncDispatcher是中央事件处理分发器，ResourceManager启动时，通过它绑定了几种类型的事件的处理器，包括SchedulerEventType、RMAppEventType、ApplicationAttempt、RMAppAttemptEventType、RMNodeEventType、RMAppManagerEventType、AMLaunchEventType等。</p>
<p>上述各service在ResourceManager中的启动顺序为：</p>
<ol>
<li><p>AsyncDispatcher</p>
</li>
<li><p>AdminService</p>
</li>
<li><p>RMActiveServices：是个CompositeService（即service列表，ResourceManager本身就是一个CompositeService），用于管理ResourceManager中的“活动”服务（必须在active的ResourceManager上启动的服务，启用HA时，备份ResourceManager上不启动这些服务），包括以下（按启动顺序）：</p>
<ul>
<li><p>RMSecretManagerService</p>
</li>
<li><p>ContainerAllocationExpirer</p>
</li>
<li><p>AMLivelinessMonitor</p>
</li>
<li><p>RMNodeLabelsManager</p>
</li>
<li><p>RMApplicationHistoryWriter</p>
</li>
<li><p>SystemMetricsPublisher</p>
</li>
<li><p>NodesListManager</p>
</li>
<li><p>ResourceScheduler</p>
</li>
<li><p>SchedulerEventDispatcher</p>
</li>
<li><p>NMLivelinessMonitor</p>
</li>
<li><p>ResourceTrackerService</p>
</li>
<li><p>ApplicationMasterService</p>
</li>
<li><p>ClientRMService</p>
</li>
<li><p>ApplicationMasterLauncher</p>
</li>
<li><p>DelegationTokenRenewer</p>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mac系统下hadoop-2.7源码编译、导入eclipse及打包]]></title>
      <url>http://maohong.github.io/2015/05/18/mac%E7%B3%BB%E7%BB%9F%E4%B8%8Bhadoop-2-7%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E3%80%81%E5%AF%BC%E5%85%A5eclipse%E5%8F%8A%E6%89%93%E5%8C%85/</url>
      <content type="html"><![CDATA[<h2 id="编译环境要求"><a href="#编译环境要求" class="headerlink" title="编译环境要求"></a>编译环境要求</h2><blockquote>
<p>JDK1.7+<br>MAVEN 3.0以上版本<br>如果需要编译native code，还需要CMake 2.6、Zlib devel、openssl devel（mac下一般安装了xcode后应该都会有这些包）。</p>
</blockquote>
<h2 id="编译方法"><a href="#编译方法" class="headerlink" title="编译方法"></a>编译方法</h2><p>解压源码包hadoop-2.7.0-src.tar.gz，iterm下进入文件夹hadoop-2.7.0-src，然后根据需要执行相应的mvn命令就可以了。</p>
<blockquote>
<p>仅编译：mvn compile<br>打包生成jar：mvn package<br>生成eclipse项目：eclipse:eclipse -DskipTests，加上-DskipTests可跳过test阶段。</p>
</blockquote>
<p>期间遇到几个问题，记录如下。</p>
<h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><p>先执行mvn eclipse:eclipse -DskipTest生成eclipse项目，执行到一半时，提示下面的报错：</p>
<font color="red">‘protoc –version’ did not return a version -&gt; [Help 1]</font>

<p>意思也就是是找不到protoc命令，安装protocolbuffer后重试，又提示错误：</p>
<font color="red">protoc version is ‘libprotoc 2.6.1′, expected version is ’2.5.0′</font>

<p>看上去是protocolbuffer版本问题，hadoop需要的版本是2.5.0，而系统安装的是2.6.1，查了很多资料，都是说protocolbuffer版本太低后来升到2.5的，而我这是2.6.1的版本，难不成还得降回去，不至于吧。因此，猜测这个版本限制是在pom.xml中写死的，于是grep了一下，发现果然在hadoop-project/pom.xml中配置了编译时使用的pb版本。</p>
<font color="red">\<protobuf.version>2.5.0\</protobuf.version></font>

<p>把以上配置项改为2.6.1，再重新执行生成eclipse项目的命令就OK了。</p>
<h2 id="导入eclipse及打包"><a href="#导入eclipse及打包" class="headerlink" title="导入eclipse及打包"></a>导入eclipse及打包</h2><p>生成eclipse项目后，从eclipse里import existing project into workspace，选择hadoop-2.7.0-src目录，就会把所有代码模块导入eclipse了。接下来就可以看代码并修改了，比如增加一些日志信息等。</p>
<p>代码修改完毕后，可以再打出一个新的hadoop-distribution包来验证代码修改效果。</p>
<p>在hadoop-2.7.0-src目录下执行命令：<font color="red">mvn package -Pdist -Ptar -Pdocs -skipTests </font></p>
<p>等上漫长的一段时间，编译成功后，可以到hadoop-dist/target下找到新的jar包。</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20150518-hadoop%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85/1.png" alt=""></p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>编译过程需要从maven中央仓库下载大量依赖包，我使用的是oschina的库。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;mirror&gt;</div><div class="line">  &lt;id&gt;CN&lt;/id&gt;</div><div class="line">  &lt;name&gt;OSChina Central&lt;/name&gt;</div><div class="line">  &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt;</div><div class="line">  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</div><div class="line">&lt;/mirror&gt;</div><div class="line">  &lt;profile&gt;</div><div class="line">	&lt;id&gt;oschina&lt;/id&gt;</div><div class="line">	&lt;repositories&gt;</div><div class="line">		&lt;repository&gt;</div><div class="line">			&lt;id&gt;nexus&lt;/id&gt;</div><div class="line">			&lt;name&gt;local private nexus&lt;/name&gt;</div><div class="line">			&lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt;</div><div class="line">			&lt;releases&gt;</div><div class="line">				&lt;enabled&gt;true&lt;/enabled&gt;</div><div class="line">			&lt;/releases&gt;</div><div class="line">			&lt;snapshots&gt;</div><div class="line">				&lt;enabled&gt;false&lt;/enabled&gt;</div><div class="line">			&lt;/snapshots&gt;</div><div class="line">		&lt;/repository&gt;</div><div class="line">	&lt;/repositories&gt;</div><div class="line">	&lt;pluginRepositories&gt;</div><div class="line">		&lt;pluginRepository&gt;</div><div class="line">			&lt;id&gt;nexus&lt;/id&gt;</div><div class="line">			&lt;name&gt;local private nexus&lt;/name&gt;</div><div class="line">			&lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt;</div><div class="line">			&lt;releases&gt;</div><div class="line">				&lt;enabled&gt;true&lt;/enabled&gt;</div><div class="line">			&lt;/releases&gt;</div><div class="line">			&lt;snapshots&gt;</div><div class="line">				&lt;enabled&gt;false&lt;/enabled&gt;</div><div class="line">			&lt;/snapshots&gt;</div><div class="line">		&lt;/pluginRepository&gt;</div><div class="line">	&lt;/pluginRepositories&gt;</div><div class="line">  &lt;/profile&gt;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用hexo+gitpage搭建博客]]></title>
      <url>http://maohong.github.io/2014/09/02/%E4%BD%BF%E7%94%A8hexo-gitpage%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>系统：mac osx<br>软件：Node.js，npm，git，hexo<br>具体安装以及git与github打通的配置就不详述了，可以google到各种方法。  </p>
<h2 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h2><p>hexo init &lt;folder&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #表示执行init命令初始化hexo到你指定的目录  </p>
<p><font color="red">以下命令需要在&lt;folder&gt;目录下执行：</font><br>hexo generate  &nbsp;&nbsp;&nbsp;#自动根据当前目录下文件,生成静态网页<br>hexo server &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#运行本地服务  </p>
<p>启动服务后，就可以通过访问 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 来看看效果了。<br>接下来，可以使用以下命令来创建一篇新博文：<br>hexo new “test blog 1”<br>创建一个名为test blog 1的博客页面，对应的md文件路径是&lt;folder&gt;/source/_posts\test blog 1.md  </p>
<p>接下来就可以在这个md文件中写文章了，我使用的是MacDown来编辑md文件，支持实时查看页面效果，还是挺好用的。</p>
<h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><p>文章写好后，通过以下方式发布到github上。<br>1.编辑./_config.yml文件，修改以下部分，配置本地内容同步至github：  </p>
<blockquote>
<p> deploy:<br> &nbsp;&nbsp;type: git<br> &nbsp;&nbsp;repository: git@github.com:maohong/maohong.github.io.git<br> &nbsp;&nbsp;branch: master  </p>
</blockquote>
<p>2.执行hexo generate(hexo g)生成html内容<br>3.执行hexo deploy(hexo d)讲更新内容发布至guthub  </p>
<p>然后就可以访问主页查看效果了，可以使用github帐户名.github.io进行访问, 也可以设置个性域名。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[redis服务端连接断开问题诊断]]></title>
      <url>http://maohong.github.io/2014/06/01/redis%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD/</url>
      <content type="html"><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>前段时间，由于线上redis服务器的内存使用率达到了机器总内存的50%以上，导致内存数据的dump持久化一直失败。扩展到多台redis后，应用系统访问redis时，在业务量较少时，时不时会出现以下异常，当业务量较大，redis访问频率很高时，却不会发生这个异常，一时觉得很诡异。</p>
<blockquote>
<p>redis.clients.jedis.exceptions.JedisConnectionException: It seems like server has closed the connection.<br>at redis.clients.util.RedisInputStream.readLine(RedisInputStream.java:90) ~[jedis-2.1.0.jar:na]<br>at redis.clients.jedis.Protocol.processInteger(Protocol.java:110) ~[jedis-2.1.0.jar:na]<br>at redis.clients.jedis.Protocol.process(Protocol.java:70) ~[jedis-2.1.0.jar:na]<br>at redis.clients.jedis.Protocol.read(Protocol.java:131) ~[jedis-2.1.0.jar:na]<br>at redis.clients.jedis.Connection.getIntegerReply(Connection.java:188) ~[jedis-2.1.0.jar:na]<br>at redis.clients.jedis.Jedis.sismember(Jedis.java:1266) ~[jedis-2.1.0.jar:na]</p>
</blockquote>
<p>看提示，应该是服务端主动关闭了连接。查看了新上线的redis服务器的配置，有这么一项：</p>
<blockquote>
<p># Close the connection after a client is idle for N seconds (0 to disable)<br>timeout 120</p>
</blockquote>
<p>这项配置指的是客户端连接空闲超过多少秒后，服务端主动关闭连接，默认值0表示服务端永远不主动关闭。而op人员把服务器端的超时时间设置为了120秒。</p>
<p>这就解释了发生这个异常的原因。客户端使用了一个连接池管理访问redis的所有连接，这些连接是长连接，当业务量较小时，客户端部分连接使用率较低，当两次使用之间的间隔超过120秒时，redis服务端就主动关闭了这个连接，而等客户端下次再使用这个连接对象时，发现服务端已经关闭了连接，进而报错。</p>
<p>于是，再查看访问redis的系统（客户端）的配置：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20140601-redis%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1.png" alt=""></p>
<p>客户端使用的是jedis内置的连接池，看其源码本质上是基于apache commons-pool实现的，其中有一个eviction线程，用于回收idle对象，对于redis连接池来说，也就是回收空闲连接。</p>
<p>JedisPoolConfig类继承自GenericObjectPoolConfig并覆盖了几项关于eviction线程的配置，具体如下：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20140601-redis%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/2.png" alt=""></p>
<p><em><font color="red">_timeBetweenEvictionRunsMillis</font></em>：eviction线程的运行周期。默认是-1，表示不启动eviction线程。这里设置为30秒。</p>
<p><em><font color="red">_minEvictableIdleTimeMillis</font></em>：对象处于idle状态的最长时间，默认是30分钟，这里设置为60秒。</p>
<p>通过客户端的默认配置看，对象的最大空闲时长是小于服务端的配置的，应该不是配置上的问题了。</p>
<p>于是，继续看是不是客户端代码使用上的问题。追踪到客户端代码如下：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20140601-redis%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/3.png" alt=""></p>
<p>可见，客户端首先尝试从本线程的ThreadLocal对象中获取jedis对象，若获取不到，再从masterJedisPool中取得jedis对象并放入ThreadLocal对象以便下次使用，并且jedis对象使用完毕后，没有从ThreadLocal中清除，也没有returnResource给masterJedisPool。</p>
<p>因此，问题产生的原因就在于此。ThreadLocal中的这个jedis对象被取出后没有return，对于对象池来说是处于非idle状态，因此不会被对象池evict。<font color="red">当业务量大时，这个jedis会被频繁使用，服务端认为这个jedis对应的连接是非空闲的，或者空闲时间达不到120秒，不会主动关闭，所以没什么问题。然而当业务量小时，这个jedis使用频率很低，当两次之间的使用间隔超出120秒时，服务端会主动把这个jedis的连接关闭，第二次调用时，就会出现上面的报错。</font></p>
<p>从代码开发者的角度来说，这么做的目的是避免频繁从pool中获取jedis对象和return jedis对象以提高性能。</p>
<p>解决方案有两个：</p>
<ol>
<li><p>在redis-cli下在线修改redis 的配置，把timeout改回为0，无需重启redis即可直接生效，但redis若重启，配置会恢复。</p>
</li>
<li><p>修改客户端代码，使用完jedis对象后，从ThreadLocal中清除，再返回给连接池。</p>
</li>
</ol>
<p>出于改动成本考虑，先采用了第一种方案，在线修改redis配置后，报错不再出现。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于zookeeper的分布式独占锁实现]]></title>
      <url>http://maohong.github.io/2014/05/13/%E5%9F%BA%E4%BA%8Ezookeeper%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%8B%AC%E5%8D%A0%E9%94%81%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在分布式系统中，经常遇到这样一种场景：选举一个节点执行某一个任务，当此节点宕机后，其他节点可以接管并继续执行这个任务。由于各个节点运行的代码是一样的，彼此之间也是平等的，各个节点如何可以知道自己是否可以执行这个任务呢？当有节点宕机时，又如何判断自己是否可以接管任务呢？在我们的分布式任务调度系统中，需要选取调度器集群中的一个节点进行轮询任务状态，这里使用了zookeeper来实现一个统一的分布式锁，从而选出轮询节点。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>如图所示，每台服务器启动后，都在同一目录下建一个临时顺序节点（EPHEMERAL_SEQUENTIAL），并获取此目录下的所有节点信息，如果自己的序号是最小的，就认为获取到了锁，可以执行任务。若自己的节点不是最小的，就认为自己没有获取到锁，不执行任务，同时，在比自己小1个序号的节点上增加监听。当比自己小1个序号的节点发生变化的时候，再次检查自己是否是最小序号的节点，如果是则获取锁，否则继续监听比自己小1个序号的节点。</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20140502-%E5%9F%BA%E4%BA%8Ezookeeper%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%8B%AC%E5%8D%A0%E9%94%81%E5%AE%9E%E7%8E%B0/1.jpg" alt=""></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>以下是一个demo实现程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedExclusiveLock</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">private</span> ZooKeeper zk;</div><div class="line">	<span class="keyword">private</span> String lockDir = <span class="string">"/testlock"</span>;<span class="comment">//锁节点所在zk的目录</span></div><div class="line">	<span class="keyword">private</span> String lockSymbol = <span class="string">"_lock_"</span>;<span class="comment">//锁节点标志</span></div><div class="line">	<span class="keyword">private</span> String lockName;<span class="comment">//锁节点前缀，构造锁时由外部传入</span></div><div class="line">	<span class="keyword">private</span> String waitNodePath;<span class="comment">//等待的前一个锁的节点名称</span></div><div class="line">	<span class="keyword">private</span> String myNodePath;<span class="comment">//当前锁</span></div><div class="line">	<span class="keyword">private</span> CountDownLatch latch;<span class="comment">//计数器</span></div><div class="line">	<span class="keyword">private</span> String threadId;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 创建分布式锁</div><div class="line">	 * <span class="doctag">@param</span> lockName 竞争资源标志,lockName中不能包含单词lock</div><div class="line">	 * <span class="doctag">@throws</span> Exception</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DistributedExclusiveLock</span><span class="params">(String zkServers, String lockName)</span> <span class="keyword">throws</span> Exception</span></div><div class="line">	&#123;</div><div class="line">		<span class="comment">//简单校验lockDir路径</span></div><div class="line">		<span class="keyword">if</span> (!lockDir.startsWith(<span class="string">"/"</span>))</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"LockDir Path must start with / character! lockDir="</span> + lockDir);</div><div class="line">		<span class="keyword">if</span> (lockDir.endsWith(<span class="string">"/"</span>))</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"LockDir Path must not end with / character! lockDir="</span> + lockDir);</div><div class="line"></div><div class="line">		<span class="keyword">this</span>.lockName = lockName;</div><div class="line">		<span class="keyword">this</span>.threadId = getThreadId();</div><div class="line">		<span class="comment">// 创建一个与服务器的连接</span></div><div class="line">		<span class="keyword">try</span></div><div class="line">		&#123;</div><div class="line">			zk = <span class="keyword">new</span> ZooKeeper(zkServers, <span class="number">3000</span>, <span class="keyword">this</span>);</div><div class="line">			createLockDirIfNecessary(lockDir);</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Error while initializing DistributedExclusiveLock!"</span> + e.getMessage(), e);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getThreadId</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"Thread-"</span> + Thread.currentThread().getId();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 在zk上建立lock目录，如果目录不存在，逐级创建节点</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">createLockDirIfNecessary</span><span class="params">(String zkDir)</span> <span class="keyword">throws</span> KeeperException, InterruptedException</span></div><div class="line">	&#123;</div><div class="line">		<span class="comment">//zkDir是一级节点，如/cloudscheduler</span></div><div class="line">		<span class="keyword">if</span> (zkDir.indexOf(<span class="string">"/"</span>) == zkDir.lastIndexOf(<span class="string">"/"</span>))</div><div class="line">		&#123;</div><div class="line">			Stat stat = zk.exists(zkDir, <span class="keyword">false</span>);</div><div class="line">			<span class="keyword">if</span>(stat == <span class="keyword">null</span>)&#123;</div><div class="line">				<span class="comment">// 创建一级节点</span></div><div class="line">				zk.create(zkDir, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>	<span class="comment">//zkDir非一级节点</span></div><div class="line">		&#123;</div><div class="line">			String parentDir = zkDir.substring(<span class="number">0</span>, zkDir.lastIndexOf(<span class="string">"/"</span>));</div><div class="line">			<span class="keyword">if</span> (zk.exists(parentDir, <span class="keyword">false</span>) != <span class="keyword">null</span>)</div><div class="line">			&#123;	<span class="comment">//如果父节点存在，建当前节点</span></div><div class="line">				Stat stat = zk.exists(zkDir, <span class="keyword">false</span>);</div><div class="line">				<span class="keyword">if</span>(stat == <span class="keyword">null</span>)&#123;</div><div class="line">					<span class="comment">// 创建非一级节点</span></div><div class="line">					zk.create(zkDir, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span></div><div class="line">			&#123;	<span class="comment">//否则，先建父节点，再建当前节点</span></div><div class="line">				createLockDirIfNecessary(parentDir);</div><div class="line">				createLockDirIfNecessary(zkDir);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * zookeeper节点的监视器</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (event.getType() == EventType.NodeDeleted)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.latch!=<span class="keyword">null</span>)</div><div class="line">				<span class="keyword">this</span>.latch.countDown();</div><div class="line">			<span class="keyword">try</span></div><div class="line">			&#123;</div><div class="line">				List&lt;String&gt; childrenNodes = zk.getChildren(lockDir, <span class="keyword">false</span>);</div><div class="line">				<span class="comment">// 排序</span></div><div class="line">				Collections.sort(childrenNodes);</div><div class="line">				System.out.println(<span class="string">"Node: "</span> + event.getPath()</div><div class="line">						+ <span class="string">" change event is deleted! Current locked nodes:\n\t"</span></div><div class="line">						+ StringUtils.join(childrenNodes,<span class="string">"\n\t"</span>));</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">catch</span> (KeeperException e)</div><div class="line">			&#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">catch</span> (InterruptedException e)</div><div class="line">			&#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">try</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(tryLockInner())</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			<span class="keyword">else</span></div><div class="line">				<span class="keyword">return</span> waitForLockInner(waitNodePath);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (Exception e)</div><div class="line">		&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryLockInner</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">try</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(lockName.contains(lockSymbol))</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"lockName can not contains "</span> + lockSymbol);</div><div class="line">			<span class="comment">//创建临时子节点</span></div><div class="line">			myNodePath = zk.create(lockDir + <span class="string">"/"</span> + lockName + lockSymbol, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</div><div class="line">			System.out.println(threadId + <span class="string">" created "</span> + myNodePath);</div><div class="line">			<span class="comment">//取出所有子节点</span></div><div class="line">			List&lt;String&gt; subNodes = zk.getChildren(lockDir, <span class="keyword">false</span>);</div><div class="line">			<span class="comment">//取出所有lockName的锁</span></div><div class="line">			List&lt;String&gt; lockedNodes = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">			<span class="keyword">for</span> (String node : subNodes) &#123;</div><div class="line">				String nodePrefix = node.split(lockSymbol)[<span class="number">0</span>];</div><div class="line">				<span class="keyword">if</span>(nodePrefix.equals(lockName))&#123;<span class="comment">//对锁名做个判断，前缀相同即为同一组锁</span></div><div class="line">					lockedNodes.add(node);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			Collections.sort(lockedNodes);</div><div class="line">			System.out.println(<span class="string">"Current locked nodes: \n\t"</span> + StringUtils.join(lockedNodes, <span class="string">"\n\t"</span>));</div><div class="line">			<span class="keyword">if</span>(myNodePath.equals(lockDir + <span class="string">"/"</span> + lockedNodes.get(<span class="number">0</span>)))&#123;</div><div class="line">				<span class="comment">//如果是最小的节点,则表示取得锁</span></div><div class="line">	            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	        &#125;</div><div class="line">			<span class="comment">//如果不是最小的节点，找到比自己小1的节点，在List中的位置是自己的前一位</span></div><div class="line">			String myZnodeName = myNodePath.substring(myNodePath.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>);</div><div class="line">			waitNodePath = lockDir + <span class="string">"/"</span> + lockedNodes.get(lockedNodes.indexOf(myZnodeName)-<span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (KeeperException e)</div><div class="line">		&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (InterruptedException e)</div><div class="line">		&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">waitForLockInner</span><span class="params">(String waitPath)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</div><div class="line">        Stat stat = zk.exists(waitPath, <span class="keyword">true</span>);</div><div class="line">        <span class="comment">//判断比自己小一个数的节点是否存在,如果存在则需等待锁,同时注册监听</span></div><div class="line">        <span class="keyword">if</span> (stat != <span class="keyword">null</span>)</div><div class="line">        &#123;</div><div class="line">        	System.out.println(threadId + <span class="string">" waiting for "</span> + waitPath);</div><div class="line">        	<span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        	<span class="keyword">this</span>.latch.await(); <span class="comment">//不加超时时间，无限等待</span></div><div class="line">        	<span class="comment">//</span></div><div class="line">        	<span class="comment">//waiting</span></div><div class="line">        	<span class="comment">//Zzzzz...</span></div><div class="line">        	<span class="comment">//still waiting</span></div><div class="line">        	<span class="comment">//</span></div><div class="line">        	<span class="comment">// 探测到节点变化，刷新节点信息</span></div><div class="line">        	<span class="keyword">this</span>.latch = <span class="keyword">null</span>;</div><div class="line">        	<span class="keyword">try</span></div><div class="line">			&#123;</div><div class="line">				<span class="comment">// 确认myNodePath是否真的是列表中的最小节点</span></div><div class="line">				List&lt;String&gt; childrenNodes = zk.getChildren(lockDir, <span class="keyword">false</span>);</div><div class="line">				<span class="comment">// 排序</span></div><div class="line">				Collections.sort(childrenNodes);</div><div class="line">				<span class="keyword">if</span>(myNodePath.equals(lockDir + <span class="string">"/"</span> + childrenNodes.get(<span class="number">0</span>)))</div><div class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">				<span class="keyword">else</span></div><div class="line">				&#123;</div><div class="line">				    <span class="comment">// 说明waitNodePath是由于出现异常而挂掉的 , 更新waitNodePath</span></div><div class="line">					String thisNodeName = myNodePath.substring(myNodePath.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>);</div><div class="line">					<span class="keyword">int</span> index = childrenNodes.indexOf(thisNodeName);</div><div class="line">					waitNodePath = lockDir + <span class="string">"/"</span> + childrenNodes.get(index - <span class="number">1</span>);</div><div class="line">					<span class="comment">//重新等待锁</span></div><div class="line">					<span class="keyword">return</span> waitForLockInner(waitNodePath);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">catch</span> (KeeperException e)</div><div class="line">			&#123;</div><div class="line">				e.printStackTrace();</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">catch</span> (InterruptedException e)</div><div class="line">			&#123;</div><div class="line">				e.printStackTrace();</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">try</span></div><div class="line">		&#123;</div><div class="line">			System.out.println(threadId + <span class="string">" unlock "</span> + myNodePath);</div><div class="line">			zk.delete(myNodePath,-<span class="number">1</span>);</div><div class="line">			myNodePath = <span class="keyword">null</span>;</div><div class="line">			zk.close();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (InterruptedException e)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Error while releasing lock! "</span> + e.getMessage(), e);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (KeeperException e)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Error while releasing lock! "</span> + e.getMessage(), e);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></div><div class="line">	&#123;</div><div class="line">	        <span class="comment">//一个简单的测试</span></div><div class="line">		List&lt;Thread&gt; workers = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="number">10</span>);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; ++i)</div><div class="line">		&#123;</div><div class="line">			Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()</div><div class="line">			&#123;</div><div class="line">				String zk = <span class="string">"10.12.10.169:2181,10.12.139.141:2181"</span>;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">				&#123;</div><div class="line">					<span class="keyword">try</span></div><div class="line">					&#123;</div><div class="line">						DistributedExclusiveLock lock = <span class="keyword">new</span> DistributedExclusiveLock(zk, <span class="string">"zkLock"</span>);</div><div class="line">						<span class="keyword">if</span> (lock.tryLock());</div><div class="line">						&#123;</div><div class="line">							String tid = <span class="string">"Thread-"</span> + Thread.currentThread().getId();</div><div class="line">							<span class="keyword">int</span> time = <span class="keyword">new</span> Random().nextInt(<span class="number">5000</span>);</div><div class="line">							System.out.println(tid + <span class="string">" gets lock and is working, sleep for "</span> + time + <span class="string">" ms"</span>);</div><div class="line">							Thread.sleep(time);</div><div class="line">							lock.unlock();</div><div class="line">							System.out.println(tid + <span class="string">" releases lock"</span>);</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">catch</span> (Exception e)</div><div class="line">					&#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">			thread.setDaemon(<span class="keyword">true</span>);</div><div class="line">			workers.add(thread);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (Thread t : workers)</div><div class="line">		&#123;</div><div class="line">			t.start();</div><div class="line">		&#125;</div><div class="line">		Thread.sleep(<span class="number">100000</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用httpclient引起的tcp连接数超高问题]]></title>
      <url>http://maohong.github.io/2014/03/28/%E4%BD%BF%E7%94%A8httpclient%E5%BC%95%E8%B5%B7%E7%9A%84tcp%E8%BF%9E%E6%8E%A5%E6%95%B0%E8%B6%85%E9%AB%98%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>组内的一个系统新上线了通过图片url上传图片到图片存储平台的功能。其中使用了httpclient，通过向图片存储平台发送MultipartPostMethod上传图片。当业务量较大时，10个处理线程满负荷运行，上传图片时，发现应用系统服务器的tcp连接数陡然升高，<font color="red">峰值能达到几万个tcp连接数！</font></p>
<p>排查系统代码并结合分析httpclient的源码发现，应用系统每次上传图片时，都会做new HttpClient()操作，这个操作内部默认使用的是SimpleHttpConnectionManager来管理http连接，而SimpleHttpConnectionManager有个默认字段alwaysClose=false，表示当外部程序调用了HttpMethod.releaseConnection()时并不会立即释放连接，而是保持这个连接并尝试用于后续的请求，在连接空闲一段时间后（默认3秒）才真正释放。</p>
<p>因此，当业务量较大，<font color="red">系统高并发发送post请求时，new出来的HttpClient对象会很多，而这个对象使用完毕后，而当中建立的client对象在短时间内并不会立即释放连接</font>，因此，随着时间的积累，tcp连接数保持居高不下。</p>
<p>通过查看官方文档，建议在高并发环境下使用MultiThreadedHttpConnectionManager来管理httpclient，因此，我们将httpclient改为单例后，tcp连接数回复正常水平。</p>
<p>通过管理httpclient的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HttpClient <span class="title">initHttpClient</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    HttpConnectionManagerParams params = <span class="keyword">new</span> HttpConnectionManagerParams();</div><div class="line">    <span class="comment">//指定向每个host发起的最大连接数，默认是2，太少了</span></div><div class="line">    params.setDefaultMaxConnectionsPerHost(<span class="number">1000</span>);</div><div class="line">    <span class="comment">//指定总共发起的最大连接数，默认是20，太少了</span></div><div class="line">    params.setMaxTotalConnections(<span class="number">5000</span>);</div><div class="line">    <span class="comment">//连接超时时间-10s</span></div><div class="line">    params.setConnectionTimeout(<span class="number">60</span>*<span class="number">1000</span>);</div><div class="line">    <span class="comment">//读取数据超时时间-60s</span></div><div class="line">    params.setSoTimeout(<span class="number">60</span>*<span class="number">1000</span>);</div><div class="line"> </div><div class="line">    MultiThreadedHttpConnectionManager manager = <span class="keyword">new</span> MultiThreadedHttpConnectionManager();</div><div class="line">    manager.setParams(params);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpClient(manager);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前后端的CharacterEncoding不一致导致提交的表单数据丢失问题]]></title>
      <url>http://maohong.github.io/2014/03/20/%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84CharacterEncoding%E4%B8%8D%E4%B8%80%E8%87%B4%E5%AF%BC%E8%87%B4%E6%8F%90%E4%BA%A4%E7%9A%84%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>最近在开发分布式任务调度系统的web端时，遇到一个坑，记录如下：</p>
<p>在页面上新增和修改任务，提交后，任务的属性在后端怎么都接收不到，但是在另一个协同开发的同学那边本地调试就OK，在我的本地和公共开发环境都不行，这不合理啊。。。。。</p>
<p>排查了很多地方，js、setter等等，一直没发现问题在哪。跟负责前端的同学交流了下，发现前端post的数据确实是修改过的，也就是后端接收有问题。</p>
<p>于是把最新版本和历史版本对比，发现最新版本新增了一个LogFilter，用于记录pagedelay的，仔细一看，logFilter里面是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">request.setCharacterEncoding(“UTF-<span class="number">8</span>″);</div><div class="line">response.setContentType(“text/html;charset=UTF-<span class="number">8</span>″);</div></pre></td></tr></table></figure>
<p>但页面上是GBK编码，所以导致数据在这个filter中编码出错，造成数据丢失，后端接收到的数据为null。</p>
<font color="red">解决方法：</font>

<p>把logFilter里的UTF-8改为GBK，就一切正常了。</p>
<font color="red">疑问：</font>

<ol>
<li><p>为何历史本没问题呢，因为历史版本中的logFilter配在struts2Filter之后，请求根本走不到logFilter里去。。。。</p>
</li>
<li><p>为何协同开发的同学本地调试没问题呢，那是因为他把web.xml里的LogFilter的filtermapping注掉了。。。。</p>
</li>
</ol>
<p>好一个歪萝卜大烂坑。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用shell切割文件]]></title>
      <url>http://maohong.github.io/2013/03/07/%E4%BD%BF%E7%94%A8shell%E5%88%87%E5%89%B2%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>最近工作中需要使用shell，从远程rsync数据过来预处理后提交到hdfs中，再调用pig脚本在hadoop集群上处理数据，完了fs -get下来结果文件并进行进一步处理，再推送给其他系统使用。其间需要将pig作业的结果文件合并并且均分为10个文件推送给远程服务器上的应用加载。因为结果文件比较大，远程应用拿到结果文件后使用多线程加载，所以需均分为10个小文件。虽然mr作业出来的文件结果也是part-00000、part-00001，但若pig脚本中不指定reduce任务数，产生的结果文件个数是3个，而且下下来之后需要进行重命名。与其这样还不如自己处理。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">rm -rf $TODAY_ALL_INDUSKEY</div><div class="line">	for allName in `find $TODAY_ALL_TMP_DIR -name "part-*"`</div><div class="line">		do</div><div class="line">			INFO "Processing result file" $allName</div><div class="line">			cat $allName &gt;&gt; $TODAY_ALL_INDUSKEY   #把结果文件重定向到一个文件</div><div class="line">	done</div><div class="line"></div><div class="line">	ALL_INDUSKEY_FILE_NUM=10    #拆分的文件数量</div><div class="line">	ALL_KEY_LINES=0             #结果文件行数</div><div class="line">	INFO "Split $TODAY_ALL_INDUSKEY into $ALL_INDUSKEY_FILE_NUM files"</div><div class="line">	for str in `wc -l $TODAY_ALL_INDUSKEY`;	do</div><div class="line">		t=`expr match $str "[1-9][0-9]*$"`;</div><div class="line">		if [ $t -gt 0 ]; then</div><div class="line">			ALL_KEY_LINES=$str         #获取结果文件行数</div><div class="line">			INFO "Line of $TODAY_ALL_INDUSKEY is $ALL_KEY_LINES"</div><div class="line">		fi</div><div class="line">	done</div><div class="line">	if [ $ALL_KEY_LINES -ne 0 ]; then</div><div class="line">		tmpLine=`echo "scale=2;$ALL_KEY_LINES/$ALL_INDUSKEY_FILE_NUM"|bc`    #每个小文件的行数，保留两位小数</div><div class="line">		INFO "$ALL_KEY_LINES/$ALL_INDUSKEY_FILE_NUM=$tmpLine"</div><div class="line">		subFileLines=`echo $(($&#123;tmpLine//.*/+1&#125;))`        #向上取整</div><div class="line">		INFO "Per subfile lines:$subFileLines"</div><div class="line">		split -l $subFileLines -a 1 -d $TODAY_ALL_INDUSKEY $TODAY_ALL_INDUSKEY"_"      #拆分文件</div><div class="line">	fi</div><div class="line"></div><div class="line">	if [ -f $TODAY_ALL_INDUSKEY ]; then</div><div class="line">		touch $TODAY_ALL_INDUSKEY.done       #创建done文件</div><div class="line">		rm -rf $TODAY_ALL_TMP_DIR</div><div class="line">		INFO "Process result file dir $TODAY_ALL_TMP_DIR done!"</div><div class="line">	fi</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Shell中的IFS分隔符使用]]></title>
      <url>http://maohong.github.io/2013/01/29/shell%E4%B8%AD%E7%9A%84IFS%E5%88%86%E9%9A%94%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p>在linux中，shell把每个 $IFS 字符对待成一个分隔符，且基于这些字符把其他扩展的结果分割。</p>
<p>工作中需要处理一个文件datafile，文件中有好几列，列与列之间以‘\3′分割，如下(终端下’\3′显示为方块)：</p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20130129/shell.png" alt=""></p>
<p>我需要拿到文件中<font color="blue">第三列为1</font>的数据行再做具体的处理，比如取其中的某一列数据再去其他文件grep数据等等。简单点，直接逐行cat数据吧。 </p>
<p><strong>脚本如下：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for line in `awk -F"\3" '&#123;if($3==1) print $0&#125;' datafile`</div><div class="line">    do</div><div class="line">        echo $line</div><div class="line">done</div></pre></td></tr></table></figure>
<p><strong>结果如下：</strong>  </p>
<p><img src="https://raw.githubusercontent.com/maohong/picture/master/20130129/shell2.png" alt=""> </p>
<p>本来是想要逐行打印出来的，可结果却不是我想要的，究其原因，是因为在shell的for循环中，列出集合的item时，默认是以<space>或<tab>或<newline>为分隔符，我们的数据文件中有空格，因此它就以空格分割打印了。</newline></tab></space></p>
<p>可以通过显式设置IFS的值来达到我们要的效果，修改后的脚本如下：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">oldifs=$IFS</div><div class="line">IFS=$'\n'    #change seperator to '\n' to get a line</div><div class="line">for line in `awk -F"\3" '&#123;if($3==1) print $0&#125;' datafile`</div><div class="line">    do</div><div class="line">        echo $line</div><div class="line">done</div><div class="line">IFS=$oldifs #reset seperator</div></pre></td></tr></table></figure>
<p>通过先保存当前的IFS变量的值到一个临时变量，再显式设置为我们想要的行分隔符$’\n’，然后在for循环结束后，再重置IFS的值即可。  </p>
<p><strong>结果如下：</strong><br><img src="https://raw.githubusercontent.com/maohong/picture/master/20130129/shell3.png" alt="">  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[将Hadoop RPC框架应用于多节点任务调度]]></title>
      <url>http://maohong.github.io/2013/01/21/%E5%B0%86Hadoop-RPC%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8%E4%BA%8E%E5%A4%9A%E8%8A%82%E7%82%B9%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在hadoop中，主从节点之间保持着心跳通信，用于传输节点状态信息、任务调度信息以及节点动作信息等等。 hdfs的namenode与datanode，mapreduce的jobtracker与tasktracker，hbase的hmaster与 regionserver之间的通信，都是基于hadoop RPC。Hadoop RPC是hadoop里非常基础的通信框架。hadoop 2.0以前hadoop RPC的数据序列化是通过实现自己定义的Writable接口实现，而从hadoop 2.0开始，数据的序列化工作交给了ProtocolBuffer去做。关于Hadoop RPC的实现原理已经有很多文章进行了详细的介绍（<a href="http://weixiaolu.iteye.com/blog/1504898" target="_blank" rel="external">源码级强力分析hadoop的RPC机制</a>，<a href="http://yanbohappy.sinaapp.com/?p=110" target="_blank" rel="external">Hadoop基于Protocol Buffer的RPC实现代码分析-Server端</a>，<a href="http://yanbohappy.sinaapp.com/?p=115" target="_blank" rel="external">带有HA功能的Hadoop Client端RPC实现原理与代码分析</a>），这里就不在赘述了。下面就直接引入问题和方案吧。  </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>工作中经常需要在定时任务系统上写一些定时任务，随着业务规模的增长和扩大，需要定时处理的任务越来越多，任务之间的执行间隔越来越小，某一时间段内（比如0点、整点或半点）执行的任务会越来越密集，只在一台机器上执行这些任务的话，会出现较大的风险：  </p>
<ul>
<li>任务并发度较高时，单机的系统资源将成为瓶颈  </li>
<li>如果一个任务的运行占用了整个机器的大部分资源，比如sql查询耗费巨大内存和CPU资源，将直接影响其他任务的运行  </li>
<li>任务失败后，如果仍然在同一台节点自动重新执行，失败率较高  </li>
<li>机器宕机后，必须第一时间重启机器或重新部署定时任务系统，所有任务都不能按时执行  </li>
<li>等等  </li>
</ul>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>可想而知的是，可以通过将定时任务系统进行分布式改造，使用多个节点执行任务，将任务分发到不同节点上进行处理，并且完善失败重试机制，从而提高系统稳定性，实现任务系统的高可靠。<br>既然是在多个节点之间分发任务，肯定得有个任务的管理者(主节点)，在我们现有的系统中，也就是一套可以部署定时任务的web系统，任务代码更新后，部署好这套web系统，即可通过web页面设置定时任务并且进行调度(在单个节点上执行)。执行任务的节点(子节点)有多个以后，如何分发任务到子节点呢，我们可以把任务的信息封装成一个bean，通过RPC发布给子节点，子节点通过这个任务bean获得任务信息，并在指定的时刻执行任务。同时，子节点可以通过与主节点的心跳通信将节点状态和执行任务的情况告诉主节点。<br>这样其实就与hadoop mapreduce分发任务有点相似了，呵呵，这里主节点与子节点之间的通信，我们就可以通过Hadoop RPC框架来实现了，不同的是，我们分发的任务是定时任务，发布任务时需要将任务的定时信息一并发给子节点。  </p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>单点的定时任务系统是基于Quartz的，在分布式环境下，可以继续基于Quartz进行改造，任务的定时信息可以通过Quartz中的JobDetail和Trigger对象来描述并封装，加上任务执行的入口类信息，再通过RPC由主节点发给子节点。子节点收到封装好的任务信息对象后，再构造JobDetail和Trigger，设置好启动时间后，通过入口类启动任务。下面是一个简单的demo。<br><a id="more"></a><br>以下是一个简单的定时任务信息描述对象CronJobInfo，包括JobDetailInfo和TriggerInfo两个属性：  </p>
<pre><code class="java"><span class="comment">/**
* 定时任务信息，包括任务信息和触发器信息
*/</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CronJobInfo</span> <span class="keyword">implements</span> <span class="title">Writable</span>
</span>{
    <span class="keyword">private</span> JobDetailInfo jobDetailInfo = <span class="keyword">new</span> JobDetailInfo();
    <span class="keyword">private</span> TriggerInfo triggerInfo = <span class="keyword">new</span> TriggerInfo();

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException
    </span>{
        jobDetailInfo.readFields(in);
        triggerInfo.readFields(in);
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException
    </span>{
        jobDetailInfo.write(out);
        triggerInfo.write(out);
    }
    <span class="comment">// getters and setters...</span>
}
</code></pre>
<p>任务信息JobDetailInfo，由主节点构造，子节点解析构造JobDetail对象：  </p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobDetailInfo</span> <span class="keyword">implements</span> <span class="title">Writable</span>
</span>{
    <span class="keyword">private</span> String name; <span class="comment">// 任务名称</span>
    <span class="keyword">private</span> String group = Scheduler.DEFAULT_GROUP; <span class="comment">// 任务组</span>
    <span class="keyword">private</span> String description; <span class="comment">// 任务描述</span>
    <span class="keyword">private</span> Class jobClass; <span class="comment">// 任务的启动类</span>
    <span class="keyword">private</span> JobDataMap jobDataMap; <span class="comment">// 任务所需的参数，用来给作业提供数据支持的数据结构</span>
    <span class="keyword">private</span> <span class="keyword">boolean</span> volatility = <span class="keyword">false</span>; <span class="comment">// &lt;span&gt;重启应用之后是否删除任务的相关信息,&lt;/span&gt;</span>
    <span class="keyword">private</span> <span class="keyword">boolean</span> durability = <span class="keyword">false</span>; <span class="comment">// 任务完成之后是否依然保留到数据库</span>
    <span class="keyword">private</span> <span class="keyword">boolean</span> shouldRecover = <span class="keyword">false</span>; <span class="comment">// 应用重启之后时候忽略过期任务</span>

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException
    </span>{
        name = WritableUtils.readString(in);
        group = WritableUtils.readString(in);
        description = WritableUtils.readString(in);
        String className = WritableUtils.readString(in);
        <span class="keyword">if</span> (className != <span class="keyword">null</span>)
        {
          <span class="keyword">try</span>
          {
             jobClass = Class.forName(<span class="keyword">new</span> String(className));
          }
          <span class="keyword">catch</span> (ClassNotFoundException e)
          {
             e.printStackTrace();
          }
        }
        <span class="keyword">int</span> dataMapSize = WritableUtils.readVInt(in);
        <span class="keyword">while</span> (dataMapSize-- &gt; <span class="number">0</span>)
        {
           String key = WritableUtils.readString(in);
           String value = WritableUtils.readString(in);
           jobDataMap.put(key, value);
        }
        volatility = in.readBoolean();
        durability = in.readBoolean();
        shouldRecover = in.readBoolean();
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException
    </span>{
        WritableUtils.writeString(out, name);
        WritableUtils.writeString(out, group);
        WritableUtils.writeString(out, description);
        WritableUtils.writeString(out, jobClass.getName());
        <span class="keyword">if</span> (jobDataMap == <span class="keyword">null</span>)
            WritableUtils.writeVInt(out, <span class="number">0</span>);
        <span class="keyword">else</span>
        {
            WritableUtils.writeVInt(out, jobDataMap.size());
            <span class="keyword">for</span> (Object k : jobDataMap.keySet())
            {
                WritableUtils.writeString(out, k.toString());
                WritableUtils.writeString(out, jobDataMap.get(k).toString());
            }
        }
        out.writeBoolean(volatility);
        out.writeBoolean(durability);
        out.writeBoolean(shouldRecover);
   }
   <span class="comment">//getters and setters</span>
   <span class="comment">//.....</span>
}
</code></pre>
<p>任务触发器信息TriggerInfo ，由主节点构造，子节点解析构造Trigger对象：  </p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TriggerInfo</span> <span class="keyword">implements</span> <span class="title">Writable</span>
</span>{
    <span class="keyword">private</span> String name; <span class="comment">// trigger名称</span>
    <span class="keyword">private</span> String group = Scheduler.DEFAULT_GROUP; <span class="comment">// triger组名称</span>
    <span class="keyword">private</span> String description; <span class="comment">// trigger描述</span>
    <span class="keyword">private</span> Date startTime; <span class="comment">// 启动时间</span>
    <span class="keyword">private</span> Date endTime; <span class="comment">// 结束时间</span>
    <span class="keyword">private</span> <span class="keyword">long</span> repeatInterval; <span class="comment">// 重试时间间隔</span>
    <span class="keyword">private</span> <span class="keyword">int</span> repeatCount; <span class="comment">//重试次数</span>

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException
    </span>{
       name = WritableUtils.readString(in);
       group = WritableUtils.readString(in);
       description = WritableUtils.readString(in);
       <span class="keyword">long</span> start = in.readLong();
       startTime = start==<span class="number">0</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> Date(start);
       <span class="keyword">long</span> end = in.readLong();
       endTime = end==<span class="number">0</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> Date(end);
       repeatInterval = in.readLong();
       repeatCount = in.readInt();
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException
    </span>{
       WritableUtils.writeString(out, name);
       WritableUtils.writeString(out, group);
       WritableUtils.writeString(out, description);
       out.writeLong(startTime == <span class="keyword">null</span> ? <span class="number">0</span> : startTime.getTime());
       out.writeLong(endTime == <span class="keyword">null</span> ? <span class="number">0</span> : endTime.getTime());
       out.writeLong(repeatInterval);
       out.writeInt(repeatCount);
    }
    <span class="comment">//getters and setters</span>
    <span class="comment">//.....</span>
}
</code></pre>
<p>主从节点通信的协议：  </p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskProtocol</span> <span class="keyword">extends</span> <span class="title">VersionedProtocol</span>
</span>{
    <span class="function"><span class="keyword">public</span> CronJobInfo <span class="title">hearbeat</span><span class="params">()</span></span>;
}
</code></pre>
<p>在这个demo中，主节点启动后，启动RPC server线程，等待客户端（子节点）的连接，当客户端调用heartbeat方法时，主节点将会生成一个任务信息返回给客户端：  </p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskScheduler</span> <span class="keyword">implements</span> <span class="title">TaskProtocol</span>
</span>{
    <span class="keyword">private</span> Logger logger = Logger.getLogger(getClass());
    <span class="keyword">private</span> Server server;

    <span class="function"><span class="keyword">public</span> <span class="title">TaskScheduler</span><span class="params">()</span>
    </span>{
        <span class="keyword">try</span>
        {
            server = RPC.getServer(<span class="keyword">this</span>, <span class="string">"192.168.1.101"</span>, <span class="number">8888</span>, <span class="keyword">new</span> Configuration());
            server.start();
            server.join();
        }
        <span class="keyword">catch</span> (UnknownHostException e)
        {
            e.printStackTrace();
        }
        <span class="keyword">catch</span> (IOException e)
        {
            e.printStackTrace();
        }
        <span class="keyword">catch</span> (InterruptedException e)
        {
            e.printStackTrace();
        }
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getProtocolVersion</span><span class="params">(String arg0, <span class="keyword">long</span> arg1)</span> <span class="keyword">throws</span> IOException
    </span>{
        <span class="keyword">return</span> <span class="number">1</span>;
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> CronJobInfo <span class="title">generateCronJob</span><span class="params">()</span>
    </span>{
        <span class="comment">// 1、创建JobDetial对象</span>
        JobDetailInfo detail = <span class="keyword">new</span> JobDetailInfo();
        <span class="comment">// 设置工作项</span>
        detail.setJobClass(DemoTask.class);
        detail.setName(<span class="string">"MyJob_1"</span>);
        detail.setGroup(<span class="string">"JobGroup_1"</span>);

        <span class="comment">// 2、创建Trigger对象</span>
        TriggerInfo trigger = <span class="keyword">new</span> TriggerInfo();
        trigger.setName(<span class="string">"Trigger_1"</span>);
        trigger.setGroup(<span class="string">"Trigger_Group_1"</span>);
        trigger.setStartTime(<span class="keyword">new</span> Date());
        <span class="comment">// 设置重复停止时间，并销毁该Trigger对象</span>
        Calendar c = Calendar.getInstance();
        c.setTimeInMillis(System.currentTimeMillis() + <span class="number">1000</span> * <span class="number">1L</span>);
        trigger.setEndTime(c.getTime());
        <span class="comment">// 设置重复间隔时间</span>
        trigger.setRepeatInterval(<span class="number">1000</span> * <span class="number">1L</span>);
        <span class="comment">// 设置重复执行次数</span>
        trigger.setRepeatCount(<span class="number">3</span>);

        CronJobInfo info = <span class="keyword">new</span> CronJobInfo();
        info.setJobDetailInfo(detail);
        info.setTriggerInfo(trigger);

        <span class="keyword">return</span> info;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>
    </span>{
        TaskScheduler ts = <span class="keyword">new</span> TaskScheduler();
    }

}
</code></pre>
<p>demo任务类，打印信息：  </p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTask</span> <span class="keyword">implements</span> <span class="title">Job</span>
</span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span>
            <span class="keyword">throws</span> JobExecutionException
    </span>{
        System.out.println(<span class="keyword">this</span> + <span class="string">": executing task @"</span> + <span class="keyword">new</span> Date());
    }
}
</code></pre>
<p>子节点demo，启动后连接主节点，远程调用generateCronJob方法，获得一个任务描述信息，并启动定时任务。  </p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRunner</span>
</span>{
    <span class="keyword">private</span> Logger logger = Logger.getLogger(getClass());
    <span class="keyword">private</span> TaskProtocol proxy;

    <span class="function"><span class="keyword">public</span> <span class="title">TaskRunner</span><span class="params">()</span>
    </span>{
        InetSocketAddress addr = <span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8888</span>);
        <span class="keyword">try</span>
        {
            proxy = (TaskProtocol) RPC.waitForProxy(TaskProtocol.class, <span class="number">1</span>, addr,
                    <span class="keyword">new</span> Configuration());
        }
        <span class="keyword">catch</span> (IOException e)
        {
            e.printStackTrace();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>
    </span>{
        RPC.stopProxy(proxy);
    }

    <span class="comment">/**
     * 从server获取一个定时任务
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCronJob</span><span class="params">()</span>
    </span>{
        CronJobInfo info = proxy.generateCronJob();
        JobDetail jobDetail = getJobDetail(info.getJobDetailInfo());
        SimpleTrigger trigger = getTrigger(info.getTriggerInfo());

        <span class="comment">// 创建Scheduler对象，并配置JobDetail和Trigger对象</span>
        SchedulerFactory sf = <span class="keyword">new</span> StdSchedulerFactory();
        Scheduler scheduler = <span class="keyword">null</span>;
        <span class="keyword">try</span>
        {
            scheduler = sf.getScheduler();
            scheduler.scheduleJob(jobDetail, trigger);
            <span class="comment">// 执行启动操作</span>
            scheduler.start();

        }
        <span class="keyword">catch</span> (SchedulerException e)
        {
            e.printStackTrace();
        }
    }

    <span class="comment">/**
     * <span class="doctag">@param</span> jobDetailInfo
     * <span class="doctag">@return</span>
     */</span>
    <span class="function"><span class="keyword">private</span> JobDetail <span class="title">getJobDetail</span><span class="params">(JobDetailInfo info)</span>
    </span>{
        JobDetail detail = <span class="keyword">new</span> JobDetail();
        detail.setName(info.getName());
        detail.setGroup(info.getGroup());
        detail.setDescription(info.getDescription());
        detail.setJobClass(info.getJobClass());
        detail.setJobDataMap(info.getJobDataMap());
        detail.setRequestsRecovery(info.isShouldRecover());
        detail.setDurability(info.isDurability());
        detail.setVolatility(info.isVolatility());
        logger.info(<span class="string">"client get jobdetail:"</span> + detail);
        <span class="keyword">return</span> detail;
    }

    <span class="comment">/**
     * <span class="doctag">@param</span> triggerInfo
     * <span class="doctag">@return</span>
     */</span>
    <span class="function"><span class="keyword">private</span> SimpleTrigger <span class="title">getTrigger</span><span class="params">(TriggerInfo info)</span>
    </span>{
        SimpleTrigger trigger = <span class="keyword">new</span> SimpleTrigger();
        trigger.setName(info.getName());
        trigger.setGroup(info.getGroup());
        trigger.setDescription(info.getDescription());
        trigger.setStartTime(info.getStartTime());
        trigger.setEndTime(info.getEndTime());
        trigger.setRepeatInterval(info.getRepeatInterval());
        trigger.setRepeatCount(info.getRepeatCount());
        logger.info(<span class="string">"client get trigger:"</span> + trigger);
        <span class="keyword">return</span> trigger;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>
    </span>{
        TaskRunner t = <span class="keyword">new</span> TaskRunner();
        t.getCronJob();
        t.close();
    }
}
</code></pre>
<p>先启动TaskScheduler，再启动TaskRunner，结果如下：  </p>
<blockquote>
<p>TaskScheduler日志:<br>2013-01-20 15:42:21,661 [Socket Reader #1 for port 8888] INFO  [org.apache.hadoop.ipc.Server] – Starting Socket Reader #1 for port 8888<br>2013-01-20 15:42:21,662 [main] INFO  [org.apache.hadoop.ipc.metrics.RpcMetrics] – Initializing RPC Metrics with hostName=TaskScheduler, port=8888<br>2013-01-20 15:42:21,706 [main] INFO  [org.apache.hadoop.ipc.metrics.RpcDetailedMetrics] – Initializing RPC Metrics with hostName=TaskScheduler, port=8888<br>2013-01-20 15:42:21,710 [IPC Server listener on 8888] INFO  [org.apache.hadoop.ipc.Server] – IPC Server listener on 8888: starting<br>2013-01-20 15:42:21,711 [IPC Server Responder] INFO  [org.apache.hadoop.ipc.Server] – IPC Server Responder: starting<br>2013-01-20 15:42:21,711 [IPC Server handler 0 on 8888] INFO  [org.apache.hadoop.ipc.Server] – IPC Server handler 0 on 8888: starting<br>2013-01-20 15:42:24,084 [IPC Server handler 0 on 8888] INFO  [org.mh.rpc.task.TaskScheduler] – generate a task: org.mh.rpc.task.JobDetailInfo@1f26605</p>
<p>TaskRunner:<br>2013-01-20 15:42:26,323 [main] INFO  [org.mh.rpc.task.TaskRunner] – client get jobdetail:JobDetail ‘JobGroup_1.MyJob_1′:  jobClass: ‘org.mh.rpc.quartz.GetSumTask isStateful: false isVolatile: false isDurable: false requestsRecovers: false<br>2013-01-20 15:42:26,329 [main] INFO  [org.mh.rpc.task.TaskRunner] – client get trigger:Trigger ‘Trigger_Group_1.Trigger<em>1′:  triggerClass: ‘org.quartz.SimpleTrigger isVolatile: false calendar: ‘null’ misfireInstruction: 0 nextFireTime: null<br>2013-01-20 15:42:26,382 [main] INFO  [org.quartz.simpl.SimpleThreadPool] – Job execution threads will use class loader of thread: main<br>2013-01-20 15:42:26,411 [main] INFO  [org.quartz.core.SchedulerSignalerImpl] – Initialized Scheduler Signaller of type: class org.quartz.core.SchedulerSignalerImpl<br>2013-01-20 15:42:26,411 [main] INFO  [org.quartz.core.QuartzScheduler] – Quartz Scheduler v.1.6.5 created.<br>2013-01-20 15:42:26,413 [main] INFO  [org.quartz.simpl.RAMJobStore] – RAMJobStore initialized.<br>2013-01-20 15:42:26,413 [main] INFO  [org.quartz.impl.StdSchedulerFactory] – Quartz scheduler ‘DefaultQuartzScheduler’ initialized from default resource file in Quartz package: ‘quartz.properties’<br>2013-01-20 15:42:26,413 [main] INFO  [org.quartz.impl.StdSchedulerFactory] – Quartz scheduler version: 1.6.5<br>2013-01-20 15:42:26,415 [main] INFO  [org.quartz.core.QuartzScheduler] – Scheduler DefaultQuartzScheduler</em>$_NON_CLUSTERED started.<br>org.mh.rpc.quartz.DemoTask@1b66b06: executing task @Sun Jan 20 15:42:26 CST 2013</p>
</blockquote>
<p>上面是一个简单的demo，演示了如何通过RPC将任务调度给节点去执行，对于Quartz来说，任务的形式可以千变万化，关键就看怎么去使用了，分发到多个节点上执行的话，就还需要对任务的信息做更多的封装了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用zookeeper协调多服务器的任务处理]]></title>
      <url>http://maohong.github.io/2012/11/13/%E4%BD%BF%E7%94%A8zookeeper%E5%8D%8F%E8%B0%83%E5%A4%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>Zookeeper</strong>是hadoop的子项目，是google的chubby的开源实现，是一个针对大规模分布式系统的可靠的分布式协调系统。Zookeeper一般部署在一个集群上，通过在集群间维护一个数据树，使得连接到集群的client能够获得统一的数据信息，比如系统公共配置信息、节点存活状态等等。因此，在互联网公司中，zookeeper被广泛运用于统一配置管理、名字服务、分布式同步等。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们看下这样一种场景：<br>前台系统每时每刻都生成大量数据，这些原生数据由后台系统处理完毕后再作他用，我们暂且不谈这些数据的存储形式，只关注如何能够尽可能高效的处理。举个例子，前台系统可能是微博的前端发布系统、搜索引擎上的广告投放系统，或者是任务发布系统，后台系统则可能是对微博和广告信息的审查系统，比如用户发的微博如果包含近期敏感信息则不予显示，若是任务，后台系统则负责处理任务具体的执行。<br>若数据量和任务量较小，单节点的后台系统或许可以处理得过来，但是如果数据量和任务量很大（比如新浪微博，龙年正月初一0点0分0秒，共有32312条微博同时发布），单节点的后台系统肯定吃不消，这时候，可想而知的是多节点同时处理前台过来的数据。<br>最简单的方法是，按消息id对后台节点数取模（msgid%server_num=mod），每个后台节点取自己那份数据进行处理，这就需要每个节点都知晓当前有多少个后台节点以及本节点所应取的mod数。但是，当某个节点宕机时，这个节点所应处理的数据无法被继续处理了，势必会造成阻塞，除非重新配置各节点上的参数，将节点数server_num减1，并修改各节点取数据的mod数。<br>毋庸置疑，这样非常麻烦！如果能够将这种配置信息（实际上是数据在节点间分配的控制信息）统一管理起来，在配置信息发生变化时，各个后台节点能够及时知晓其变化，就可以避免上述情况的发生。<br>因此，采用多节点处理数据时，有两个问题：<br>1.避免多个节点重复处理同一条数据，否则造成资源浪费。<br>2.不能有数据被遗漏处理，尤其是在有后台节点down掉的时候。<br>也就是说，采用多节点同时处理数据时，需要将数据隔离开，分别给不同的节点处理，而且在有节点宕机的情况下，所有数据也必须可以无误的被其他可用节点处理。如何做到这一点呢，使用zookeeper吧！<br><a id="more"></a></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们通过zookeeper维护一个目录（比如/app/config），服务器启动时连接zookeeper集群并在该目录下创建表示自己的临时节点（CreateMode.EPHEMERAL），相当于注册一个节点，节点名可以是本服务器的ip，节点的值为该服务器的mod值，按注册顺序从0递增，即第一个注册的节点值为0，第二个为1，依次下去，因此/app/config的子节点数就是注册到zookeeper的服务器数。同时，各服务器监听/app/config目录，当其发生变化（新加入子节点、子节点失效等）时，每个服务器都将获取到这个事件并进行相应的处理。  </p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>下面针对以上场景给出一个示例demo。<br><strong>Server类</strong>：服务器<br><strong>ClientThread类</strong>：服务器上的单个线程<br><strong>NodeStateWatcher类</strong>：服务器监听zookeeper集群的监听器<br><strong>ZkOperationImpl类</strong>：zookeeper的操作封装（实现ZkOperation接口）<br>Server.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></div><div class="line">&#123;</div><div class="line"> <span class="keyword">private</span> ClientThread[] clients = <span class="keyword">new</span> ClientThread[Constant.THREAD_COUNT]; <span class="comment">// 数据处理线程</span></div><div class="line"> <span class="keyword">private</span> ZkOperation operationCient = <span class="keyword">null</span>; <span class="comment">// 与zookeeper的连接</span></div><div class="line"> <span class="keyword">private</span> Watcher nodeWatcher = <span class="keyword">null</span>;  <span class="comment">// 向zookeeper注册的监听器</span></div><div class="line"> <span class="keyword">private</span> String name; <span class="comment">// 服务器名</span></div><div class="line"> <span class="keyword">private</span> String ip; <span class="comment">// 服务器ip</span></div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">(String name, String ip)</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException</span></div><div class="line"> &#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.ip = ip;</div><div class="line">  <span class="keyword">this</span>.operationCient = <span class="keyword">new</span> ZkOperationImpl();</div><div class="line">  <span class="keyword">this</span>.nodeWatcher = <span class="keyword">new</span> NodeStateWatcher(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">this</span>.operationCient.init(Constant.ZK_ADDRESS, nodeWatcher);</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;Constant.THREAD_COUNT; ++i)</div><div class="line">  &#123;</div><div class="line">   ClientThread c = <span class="keyword">new</span> ClientThread(i, ip, name);</div><div class="line">   <span class="keyword">this</span>.clients[i]= c;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  initialize();</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="comment">/**</span></div><div class="line">  * 向zookeeper集群注册</div><div class="line">  * <span class="doctag">@throws</span> InterruptedException</div><div class="line">  * <span class="doctag">@throws</span> KeeperException</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServer</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException</span></div><div class="line"> &#123;</div><div class="line">  List&lt;String&gt; children = operationCient.getChilds(Constant.ROOT_PATH);</div><div class="line">  <span class="keyword">int</span> max = -<span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span> (String childName : children)</div><div class="line">  &#123;</div><div class="line">   String childPath = Constant.ROOT_PATH + <span class="string">"/"</span> + childName;</div><div class="line">   <span class="keyword">int</span> mod = Integer.parseInt(operationCient.getData(childPath));</div><div class="line">   <span class="keyword">if</span> (mod &gt; max)</div><div class="line">    max = mod;</div><div class="line">  &#125;</div><div class="line">  String path = Constant.ROOT_PATH + <span class="string">"/"</span> + ip;</div><div class="line">  operationCient.apendTempNode(path, String.valueOf(max&lt;<span class="number">0</span> ? <span class="number">0</span> : ++max));</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="comment">/**</span></div><div class="line">  * 启动数据处理线程</div><div class="line">  * <span class="doctag">@throws</span> Exception</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line"> &#123;</div><div class="line">  <span class="keyword">for</span> (ClientThread c : clients)</div><div class="line">  &#123;</div><div class="line">   CommonUtil.log(<span class="string">"Start thread-"</span> + c);</div><div class="line">   c.start();</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="comment">/**</span></div><div class="line">  * 服务器初始化</div><div class="line">  * <span class="doctag">@throws</span> InterruptedException</div><div class="line">  * <span class="doctag">@throws</span> KeeperException</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException</span></div><div class="line"> &#123;</div><div class="line">  CommonUtil.log(<span class="string">"================"</span>);</div><div class="line">  CommonUtil.log(<span class="keyword">this</span> + <span class="string">" initializing..."</span>);</div><div class="line"> </div><div class="line">  <span class="comment">// 配置信息的上级目录不存在</span></div><div class="line">  <span class="keyword">if</span> (!operationCient.exist(Constant.ROOT_PATH))</div><div class="line">  &#123;</div><div class="line">   System.err.println(<span class="string">"Root path "</span> + Constant.ROOT_PATH + <span class="string">"does not exist!!! Create root path..."</span>);</div><div class="line">   operationCient.apendPresistentNode(Constant.ROOT_PATH, <span class="string">"1"</span>);</div><div class="line">   CommonUtil.log(<span class="string">"Create root path "</span> + Constant.ROOT_PATH + <span class="string">" successfully!"</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  registerServer();</div><div class="line"> </div><div class="line">  refreshConfig();</div><div class="line"> </div><div class="line">  CommonUtil.log(<span class="keyword">this</span> + <span class="string">" finish initializing..."</span>);</div><div class="line">  CommonUtil.log(<span class="string">"================"</span>);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="comment">/**</span></div><div class="line">  * watch到节点变化后，刷新节点数和模数</div><div class="line">  * <span class="doctag">@throws</span> InterruptedException</div><div class="line">  * <span class="doctag">@throws</span> KeeperException</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException</span></div><div class="line"> &#123;</div><div class="line">  CommonUtil.log(<span class="string">"================"</span>);</div><div class="line">  CommonUtil.log(<span class="keyword">this</span> + <span class="string">":freshing..."</span>);</div><div class="line"> </div><div class="line">  refreshConfig();</div><div class="line"> </div><div class="line">  CommonUtil.log(<span class="keyword">this</span> + <span class="string">":end freshing..."</span>);</div><div class="line">  CommonUtil.log(<span class="string">"================"</span>);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshConfig</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException</span></div><div class="line"> &#123;</div><div class="line">  String version = operationCient.getData(Constant.ROOT_PATH);</div><div class="line">  CommonUtil.log(<span class="string">"SYSTEM VERSION: "</span> + version);</div><div class="line">  List&lt;String&gt; children = operationCient.getChilds(Constant.ROOT_PATH);</div><div class="line"> </div><div class="line">  <span class="comment">// 1. 服务器数量为子节点的个数</span></div><div class="line">  <span class="keyword">int</span> nodeCount = children.size();</div><div class="line">  CommonUtil.log(<span class="string">"Server count:"</span> + nodeCount);</div><div class="line">  <span class="keyword">synchronized</span> (CommonUtil.BASE)</div><div class="line">  &#123;</div><div class="line">   CommonUtil.BASE = nodeCount * Constant.THREAD_COUNT;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">if</span> (CommonUtil.BASE.intValue() == <span class="number">0</span>)</div><div class="line">   <span class="keyword">return</span>;</div><div class="line"> </div><div class="line">  Integer mod = <span class="keyword">null</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (String childName : children)</div><div class="line">  &#123;</div><div class="line">   <span class="comment">// 2. 获取本服务器的模数</span></div><div class="line">   <span class="keyword">if</span> (childName.equals(ip))</div><div class="line">   &#123;</div><div class="line">    String childPath = Constant.ROOT_PATH + <span class="string">"/"</span> + childName;</div><div class="line">    mod = Integer.parseInt(operationCient.getData(childPath));</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 3. 刷新数据处理线程的取模数</span></div><div class="line">  <span class="keyword">if</span> (mod == <span class="keyword">null</span>)</div><div class="line">  &#123;</div><div class="line">   System.err.println(<span class="string">"Did not get the mod number for "</span> + <span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">   CommonUtil.log(<span class="keyword">this</span> + <span class="string">", mod="</span> + mod + <span class="string">",base="</span> + CommonUtil.BASE);</div><div class="line">   <span class="keyword">for</span> (ClientThread c : clients)</div><div class="line">   &#123;</div><div class="line">    c.refresh(mod);</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></div><div class="line"> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">"@"</span> + <span class="keyword">this</span>.ip + <span class="string">""</span>;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="keyword">public</span> ClientThread[] getClients()</div><div class="line"> &#123;</div><div class="line">  <span class="keyword">return</span> clients;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">public</span> ZkOperation <span class="title">getOperationCient</span><span class="params">()</span></span></div><div class="line"> &#123;</div><div class="line">  <span class="keyword">return</span> operationCient;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">public</span> Watcher <span class="title">getNodeWatcher</span><span class="params">()</span></span></div><div class="line"> &#123;</div><div class="line">  <span class="keyword">return</span> nodeWatcher;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getIp</span><span class="params">()</span></span></div><div class="line"> &#123;</div><div class="line">  <span class="keyword">return</span> ip;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ClientThread.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></div><div class="line">&#123;</div><div class="line"> </div><div class="line"> <span class="keyword">private</span> Integer modNum = -<span class="number">1</span>;</div><div class="line"> <span class="keyword">private</span> Integer threadId;</div><div class="line"> <span class="keyword">private</span> String ip;</div><div class="line"> <span class="keyword">private</span> String clientName;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(Integer threadId, String ip, String clientName)</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException</span></div><div class="line"> &#123;</div><div class="line">  <span class="keyword">this</span>.threadId = threadId;</div><div class="line">  <span class="keyword">this</span>.ip = ip;</div><div class="line">  <span class="keyword">this</span>.clientName = clientName;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="comment">/**</span></div><div class="line">  * watch到节点变化后，调用刷新节点数和模数</div><div class="line">  * <span class="doctag">@throws</span> InterruptedException</div><div class="line">  * <span class="doctag">@throws</span> KeeperException</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(<span class="keyword">int</span> mod)</span> <span class="keyword">throws</span> KeeperException, InterruptedException</span></div><div class="line"> &#123;</div><div class="line"><span class="comment">//  CommonUtil.log("================");</span></div><div class="line"><span class="comment">//  CommonUtil.log(this + ":freshing...");</span></div><div class="line"> </div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.modNum)</div><div class="line">  &#123;</div><div class="line">   <span class="keyword">this</span>.modNum = threadId + mod * Constant.THREAD_COUNT;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  CommonUtil.log(<span class="keyword">this</span> + <span class="string">":"</span> + modNum + <span class="string">"/"</span> + CommonUtil.BASE);</div><div class="line"> </div><div class="line"><span class="comment">//  CommonUtil.log(this + ":end freshing...");</span></div><div class="line"><span class="comment">//  CommonUtil.log("================");</span></div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line"> &#123;</div><div class="line">  <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">  <span class="keyword">while</span> (System.currentTimeMillis() - start &lt; Constant.DURATION)</div><div class="line">  &#123;</div><div class="line">   <span class="comment">// 处理数据</span></div><div class="line">   processData();</div><div class="line">   <span class="keyword">try</span></div><div class="line">   &#123;</div><div class="line">    Thread.sleep(<span class="number">5000</span>); <span class="comment">//等待2秒</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">catch</span> (InterruptedException e)</div><div class="line">   &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="comment">/**</span></div><div class="line">  * 模拟处理数据逻辑：打印属于本线程的数据</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span></span></div><div class="line"> &#123;</div><div class="line">  <span class="keyword">if</span> (CommonUtil.BASE.equals(<span class="number">0</span>) || modNum.equals(-<span class="number">1</span>))</div><div class="line">  &#123;</div><div class="line">   CommonUtil.err(<span class="keyword">this</span> + <span class="string">": did not get server_count and modNum!!!"</span>);</div><div class="line">   <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="keyword">this</span> + <span class="string">"-"</span> + modNum + <span class="string">"/"</span> + CommonUtil.BASE + <span class="string">":"</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;Constant.NUMBERS.length; ++i)</div><div class="line">  &#123;</div><div class="line">   <span class="keyword">int</span> n = Constant.NUMBERS[i];</div><div class="line">   <span class="keyword">if</span> (n % CommonUtil.BASE == modNum)</div><div class="line">   &#123;</div><div class="line">    sb.append(n).append(<span class="string">" "</span>);</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line">  CommonUtil.log(sb.toString());</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></div><div class="line"> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"ClientThread_"</span> + <span class="keyword">this</span>.clientName + <span class="string">"@"</span> + <span class="keyword">this</span>.ip + <span class="string">"-thread_"</span> + <span class="keyword">this</span>.threadId;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">public</span> Integer <span class="title">getModNum</span><span class="params">()</span></span></div><div class="line"> &#123;</div><div class="line">  <span class="keyword">return</span> modNum;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setModNum</span><span class="params">(Integer modNum)</span></span></div><div class="line"> &#123;</div><div class="line">  <span class="keyword">this</span>.modNum = modNum;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getClientName</span><span class="params">()</span></span></div><div class="line"> &#123;</div><div class="line">  <span class="keyword">return</span> clientName;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NodeStateWatcher.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeStateWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span></div><div class="line">&#123;</div><div class="line"> <span class="keyword">private</span> Server server;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">NodeStateWatcher</span><span class="params">(Server server)</span></span></div><div class="line"> &#123;</div><div class="line">  <span class="keyword">this</span>.server = server;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span></span></div><div class="line"> &#123;</div><div class="line">  StringBuilder outputStr = <span class="keyword">new</span> StringBuilder();</div><div class="line">  <span class="keyword">if</span> (server.getName() != <span class="keyword">null</span>)</div><div class="line">  &#123;</div><div class="line">   outputStr.append(server.getName() + <span class="string">" get an event."</span>);</div><div class="line">  &#125;</div><div class="line">  outputStr.append(<span class="string">"Path:"</span> + event.getPath());</div><div class="line">  outputStr.append(<span class="string">",state:"</span> + event.getState());</div><div class="line">  outputStr.append(<span class="string">",type:"</span> + event.getType());</div><div class="line">  CommonUtil.log(outputStr.toString());</div><div class="line"> </div><div class="line">  <span class="comment">// 发现子节点有变化</span></div><div class="line">  <span class="keyword">if</span> (event.getType() == EventType.NodeChildrenChanged</div><div class="line">    || event.getType() == EventType.NodeDataChanged</div><div class="line">    || event.getType() == EventType.NodeDeleted)</div><div class="line">  &#123;</div><div class="line">   CommonUtil.log(<span class="string">"In event: "</span> + event.getType());</div><div class="line">   <span class="keyword">try</span></div><div class="line">   &#123;</div><div class="line">    server.refresh();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">catch</span> (KeeperException e)</div><div class="line">   &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">catch</span> (InterruptedException e)</div><div class="line">   &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">   &#125;</div><div class="line">   CommonUtil.log(<span class="string">"End event: "</span> + event.getType());</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ZkOperationImpl.java 部分zk操作代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apendPresistentNode</span><span class="params">(String path, String data)</span></span></div><div class="line">   <span class="keyword">throws</span> KeeperException, InterruptedException</div><div class="line"> &#123;</div><div class="line">  <span class="keyword">if</span> (zk != <span class="keyword">null</span>)</div><div class="line">  &#123;</div><div class="line">   zk.create(path, data.getBytes(), Ids.OPEN_ACL_UNSAFE,</div><div class="line">     CreateMode.PERSISTENT);</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(String path)</span> <span class="keyword">throws</span> KeeperException,</span></div><div class="line">   InterruptedException</div><div class="line"> &#123;</div><div class="line">  <span class="keyword">if</span> (zk != <span class="keyword">null</span>)</div><div class="line">  &#123;</div><div class="line">   zk.delete(path, -<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(String path)</span> <span class="keyword">throws</span> KeeperException,</span></div><div class="line">   InterruptedException</div><div class="line"> &#123;</div><div class="line">  <span class="keyword">if</span> (zk != <span class="keyword">null</span>)</div><div class="line">  &#123;</div><div class="line">   <span class="keyword">return</span> zk.exists(path, <span class="keyword">true</span>) != <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Main.java：主类，启动demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></div><div class="line">&#123;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></div><div class="line"> &#123;</div><div class="line">  Server c1 = <span class="keyword">new</span> Server(<span class="string">"ServerA"</span>, <span class="string">"1.1.1.1"</span>);</div><div class="line">  Server c2 = <span class="keyword">new</span> Server(<span class="string">"ServerB"</span>, <span class="string">"1.1.1.2"</span>);</div><div class="line">  Server c3 = <span class="keyword">new</span> Server(<span class="string">"ServerC"</span>, <span class="string">"1.1.1.3"</span>);</div><div class="line"> </div><div class="line">  c1.start();</div><div class="line">  c2.start();</div><div class="line">  c3.start();</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>由于Server的3个实例在同一台机器上运行，连接到zookeeper时，用的是一个session，所以demo中没有通过程序断开server与zookeeper的连接，如果serverA断开，那么serverB和serverC与zookeeper的session连接也会失效，达不到演示效果，所以我们只能暂时在zookeeper客户端手工更改zookeeper上的配置信息，用于模拟server与zookeeper集群断开连接和增加server的情形。server启动后，会先向zookeeper注册节点，因此我们先手工删除节点，再手工添加节点。<br>手工执行的命令如下：  </p>
<blockquote>
<p>[zk: localhost:2181(CONNECTED) 141] delete /demo/1.1.1.3<br>[zk: localhost:2181(CONNECTED) 142] delete /demo/1.1.1.2<br>[zk: localhost:2181(CONNECTED) 143] delete /demo/1.1.1.1<br>[zk: localhost:2181(CONNECTED) 144] create -e /demo/1.1.1.1 0<br>[zk: localhost:2181(CONNECTED) 145] create -e /demo/1.1.1.2 1<br>[zk: localhost:2181(CONNECTED) 146] create -e /demo/1.1.1.3 2  </p>
</blockquote>
<p>可以通过程序打印信息发现，在节点配置信息每个服务器(Server)上的线程会动态的获取属于自己的数据并打印。当然，这里对数据的处理逻辑很简单，仅仅是打印出来，处理的数据也只是内存中的一个数组，对于类似这样的但是更复杂的应用场景，zookeeper同样适用，但是需要更多的考虑服务器与zookeeper集群连接的可靠性（比如session超时重连）、权限机制等等。<br>上面的demo程序打印信息如下：  </p>
<blockquote>
<p>[2012-11-14 15:18:42] New zk connection session: 0<br>[2012-11-14 15:18:42] ================<br>[2012-11-14 15:18:42] ServerA@1.1.1.1 initializing…<br>[2012-11-14 15:18:47] Thread-0 get an event.Path:null,state:SyncConnected,type:None<br>[2012-11-14 15:18:47] Thread-0 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:18:47] In event: NodeChildrenChanged<br>[2012-11-14 15:18:47] ================<br>[2012-11-14 15:18:47] ServerA@1.1.1.1:freshing…<br>[2012-11-14 15:18:47] SYSTEM VERSION: 1<br>[2012-11-14 15:18:47] SYSTEM VERSION: 1<br>[2012-11-14 15:18:47] Server count:1<br>[2012-11-14 15:18:47] Server count:1<br>[2012-11-14 15:18:47] ServerA@1.1.1.1, mod=0,base=5<br>[2012-11-14 15:18:47] ClientThread_ServerA@1.1.1.1-thread_0:0/5<br>[2012-11-14 15:18:47] ClientThread_ServerA@1.1.1.1-thread_1:1/5<br>[2012-11-14 15:18:47] ClientThread_ServerA@1.1.1.1-thread_2:2/5<br>[2012-11-14 15:18:47] ClientThread_ServerA@1.1.1.1-thread_3:3/5<br>[2012-11-14 15:18:47] ClientThread_ServerA@1.1.1.1-thread_4:4/5<br>[2012-11-14 15:18:47] ServerA@1.1.1.1 finish initializing…<br>[2012-11-14 15:18:47] ================<br>[2012-11-14 15:18:47] ServerA@1.1.1.1, mod=0,base=5<br>[2012-11-14 15:18:47] ClientThread_ServerA@1.1.1.1-thread_0:0/5<br>[2012-11-14 15:18:47] ClientThread_ServerA@1.1.1.1-thread_1:1/5<br>[2012-11-14 15:18:47] ClientThread_ServerA@1.1.1.1-thread_2:2/5<br>[2012-11-14 15:18:47] ClientThread_ServerA@1.1.1.1-thread_3:3/5<br>[2012-11-14 15:18:47] ClientThread_ServerA@1.1.1.1-thread_4:4/5<br>[2012-11-14 15:18:47] ServerA@1.1.1.1:end freshing…<br>[2012-11-14 15:18:47] ================<br>[2012-11-14 15:18:47] End event: NodeChildrenChanged<br>[2012-11-14 15:18:47] New zk connection session: 0<br>[2012-11-14 15:18:47] ================<br>[2012-11-14 15:18:47] ServerB@1.1.1.2 initializing…<br>[2012-11-14 15:18:51] Thread-6 get an event.Path:null,state:SyncConnected,type:None<br>[2012-11-14 15:18:51] Thread-0 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:18:51] In event: NodeChildrenChanged<br>[2012-11-14 15:18:51] ================<br>[2012-11-14 15:18:51] ServerA@1.1.1.1:freshing…<br>[2012-11-14 15:18:51] Thread-6 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:18:51] In event: NodeChildrenChanged<br>[2012-11-14 15:18:51] ================<br>[2012-11-14 15:18:51] ServerB@1.1.1.2:freshing…<br>[2012-11-14 15:18:51] SYSTEM VERSION: 1<br>[2012-11-14 15:18:51] SYSTEM VERSION: 1<br>[2012-11-14 15:18:51] Server count:2<br>[2012-11-14 15:18:51] SYSTEM VERSION: 1<br>[2012-11-14 15:18:51] ServerA@1.1.1.1, mod=0,base=10<br>[2012-11-14 15:18:51] ClientThread_ServerA@1.1.1.1-thread_0:0/10<br>[2012-11-14 15:18:51] ClientThread_ServerA@1.1.1.1-thread_1:1/10<br>[2012-11-14 15:18:51] ClientThread_ServerA@1.1.1.1-thread_2:2/10<br>[2012-11-14 15:18:51] ClientThread_ServerA@1.1.1.1-thread_3:3/10<br>[2012-11-14 15:18:51] ClientThread_ServerA@1.1.1.1-thread_4:4/10<br>[2012-11-14 15:18:51] ServerA@1.1.1.1:end freshing…<br>[2012-11-14 15:18:51] Server count:2<br>[2012-11-14 15:18:51] ================<br>[2012-11-14 15:18:51] End event: NodeChildrenChanged<br>[2012-11-14 15:18:51] Server count:2<br>[2012-11-14 15:18:51] ServerB@1.1.1.2, mod=1,base=10<br>[2012-11-14 15:18:51] ClientThread_ServerB@1.1.1.2-thread_0:5/10<br>[2012-11-14 15:18:51] ClientThread_ServerB@1.1.1.2-thread_1:6/10<br>[2012-11-14 15:18:51] ClientThread_ServerB@1.1.1.2-thread_2:7/10<br>[2012-11-14 15:18:51] ClientThread_ServerB@1.1.1.2-thread_3:8/10<br>[2012-11-14 15:18:51] ClientThread_ServerB@1.1.1.2-thread_4:9/10<br>[2012-11-14 15:18:51] ServerB@1.1.1.2:end freshing…<br>[2012-11-14 15:18:51] ================<br>[2012-11-14 15:18:51] End event: NodeChildrenChanged<br>[2012-11-14 15:18:51] ServerB@1.1.1.2, mod=1,base=10<br>[2012-11-14 15:18:51] ClientThread_ServerB@1.1.1.2-thread_0:5/10<br>[2012-11-14 15:18:51] ClientThread_ServerB@1.1.1.2-thread_1:6/10<br>[2012-11-14 15:18:51] ClientThread_ServerB@1.1.1.2-thread_2:7/10<br>[2012-11-14 15:18:51] ClientThread_ServerB@1.1.1.2-thread_3:8/10<br>[2012-11-14 15:18:51] ClientThread_ServerB@1.1.1.2-thread_4:9/10<br>[2012-11-14 15:18:51] ServerB@1.1.1.2 finish initializing…<br>[2012-11-14 15:18:51] ================<br>[2012-11-14 15:18:51] New zk connection session: 0<br>[2012-11-14 15:18:51] ================<br>[2012-11-14 15:18:51] ServerC@1.1.1.3 initializing…<br>[2012-11-14 15:18:56] Thread-12 get an event.Path:null,state:SyncConnected,type:None<br>[2012-11-14 15:18:56] Thread-0 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:18:56] In event: NodeChildrenChanged<br>[2012-11-14 15:18:56] ================<br>[2012-11-14 15:18:56] ServerA@1.1.1.1:freshing…<br>[2012-11-14 15:18:56] Thread-6 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:18:56] In event: NodeChildrenChanged<br>[2012-11-14 15:18:56] ================<br>[2012-11-14 15:18:56] ServerB@1.1.1.2:freshing…<br>[2012-11-14 15:18:56] Thread-12 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:18:56] In event: NodeChildrenChanged<br>[2012-11-14 15:18:56] ================<br>[2012-11-14 15:18:56] ServerC@1.1.1.3:freshing…<br>[2012-11-14 15:18:56] SYSTEM VERSION: 1<br>[2012-11-14 15:18:56] SYSTEM VERSION: 1<br>[2012-11-14 15:18:56] SYSTEM VERSION: 1<br>[2012-11-14 15:18:56] Server count:3<br>[2012-11-14 15:18:56] ServerA@1.1.1.1, mod=0,base=15<br>[2012-11-14 15:18:56] ClientThread_ServerA@1.1.1.1-thread_0:0/15<br>[2012-11-14 15:18:56] Server count:3<br>[2012-11-14 15:18:56] ClientThread_ServerA@1.1.1.1-thread_1:1/15<br>[2012-11-14 15:18:56] ClientThread_ServerA@1.1.1.1-thread_2:2/15<br>[2012-11-14 15:18:56] ClientThread_ServerA@1.1.1.1-thread_3:3/15<br>[2012-11-14 15:18:56] ClientThread_ServerA@1.1.1.1-thread_4:4/15<br>[2012-11-14 15:18:56] ServerA@1.1.1.1:end freshing…<br>[2012-11-14 15:18:56] ================<br>[2012-11-14 15:18:56] End event: NodeChildrenChanged<br>[2012-11-14 15:18:56] SYSTEM VERSION: 1<br>[2012-11-14 15:18:56] Server count:3<br>[2012-11-14 15:18:56] ServerB@1.1.1.2, mod=1,base=15<br>[2012-11-14 15:18:56] ClientThread_ServerB@1.1.1.2-thread_0:5/15<br>[2012-11-14 15:18:56] ClientThread_ServerB@1.1.1.2-thread_1:6/15<br>[2012-11-14 15:18:56] ClientThread_ServerB@1.1.1.2-thread_2:7/15<br>[2012-11-14 15:18:56] ClientThread_ServerB@1.1.1.2-thread_3:8/15<br>[2012-11-14 15:18:56] ClientThread_ServerB@1.1.1.2-thread_4:9/15<br>[2012-11-14 15:18:56] ServerB@1.1.1.2:end freshing…<br>[2012-11-14 15:18:56] ================<br>[2012-11-14 15:18:56] End event: NodeChildrenChanged<br>[2012-11-14 15:18:56] Server count:3<br>[2012-11-14 15:18:56] ServerC@1.1.1.3, mod=2,base=15<br>[2012-11-14 15:18:56] ClientThread_ServerC@1.1.1.3-thread_0:10/15<br>[2012-11-14 15:18:56] ClientThread_ServerC@1.1.1.3-thread_1:11/15<br>[2012-11-14 15:18:56] ClientThread_ServerC@1.1.1.3-thread_2:12/15<br>[2012-11-14 15:18:56] ClientThread_ServerC@1.1.1.3-thread_3:13/15<br>[2012-11-14 15:18:56] ClientThread_ServerC@1.1.1.3-thread_4:14/15<br>[2012-11-14 15:18:56] ServerC@1.1.1.3:end freshing…<br>[2012-11-14 15:18:56] ================<br>[2012-11-14 15:18:56] End event: NodeChildrenChanged<br>[2012-11-14 15:18:56] ServerC@1.1.1.3, mod=2,base=15<br>[2012-11-14 15:18:56] ClientThread_ServerC@1.1.1.3-thread_0:10/15<br>[2012-11-14 15:18:56] ClientThread_ServerC@1.1.1.3-thread_1:11/15<br>[2012-11-14 15:18:56] ClientThread_ServerC@1.1.1.3-thread_2:12/15<br>[2012-11-14 15:18:56] ClientThread_ServerC@1.1.1.3-thread_3:13/15<br>[2012-11-14 15:18:56] ClientThread_ServerC@1.1.1.3-thread_4:14/15<br>[2012-11-14 15:18:56] ServerC@1.1.1.3 finish initializing…<br>[2012-11-14 15:18:56] ================<br>[2012-11-14 15:18:56] Start thread-ClientThread_ServerA@1.1.1.1-thread_0<br>[2012-11-14 15:18:56] Start thread-ClientThread_ServerB@1.1.1.2-thread_0<br>[2012-11-14 15:18:56] Start thread-ClientThread_ServerC@1.1.1.3-thread_0<br>[2012-11-14 15:18:56] Start thread-ClientThread_ServerB@1.1.1.2-thread_1<br>[2012-11-14 15:18:56] Start thread-ClientThread_ServerA@1.1.1.1-thread_1<br>[2012-11-14 15:18:56] ClientThread_ServerA@1.1.1.1-thread_0-0/15:15 30<br>[2012-11-14 15:18:56] Start thread-ClientThread_ServerA@1.1.1.1-thread_2<br>[2012-11-14 15:18:56] ClientThread_ServerC@1.1.1.3-thread_0-10/15:10 25<br>[2012-11-14 15:18:56] Start thread-ClientThread_ServerA@1.1.1.1-thread_3<br>[2012-11-14 15:18:56] ClientThread_ServerB@1.1.1.2-thread_0-5/15:5 20<br>[2012-11-14 15:18:56] Start thread-ClientThread_ServerA@1.1.1.1-thread_4<br>[2012-11-14 15:18:56] ClientThread_ServerA@1.1.1.1-thread_1-1/15:1 16<br>[2012-11-14 15:18:56] ClientThread_ServerA@1.1.1.1-thread_3-3/15:3 18<br>[2012-11-14 15:18:56] ClientThread_ServerA@1.1.1.1-thread_2-2/15:2 17<br>[2012-11-14 15:18:56] Start thread-ClientThread_ServerB@1.1.1.2-thread_2<br>[2012-11-14 15:18:56] ClientThread_ServerB@1.1.1.2-thread_1-6/15:6 21<br>[2012-11-14 15:18:56] Start thread-ClientThread_ServerB@1.1.1.2-thread_3<br>[2012-11-14 15:18:56] ClientThread_ServerB@1.1.1.2-thread_2-7/15:7 22<br>[2012-11-14 15:18:56] ClientThread_ServerB@1.1.1.2-thread_3-8/15:8 23<br>[2012-11-14 15:18:56] Start thread-ClientThread_ServerC@1.1.1.3-thread_1<br>[2012-11-14 15:18:56] Start thread-ClientThread_ServerB@1.1.1.2-thread_4<br>[2012-11-14 15:18:56] ClientThread_ServerC@1.1.1.3-thread_1-11/15:11 26<br>[2012-11-14 15:18:56] ClientThread_ServerA@1.1.1.1-thread_4-4/15:4 19<br>[2012-11-14 15:18:56] Start thread-ClientThread_ServerC@1.1.1.3-thread_2<br>[2012-11-14 15:18:56] ClientThread_ServerB@1.1.1.2-thread_4-9/15:9 24<br>[2012-11-14 15:18:56] Start thread-ClientThread_ServerC@1.1.1.3-thread_3<br>[2012-11-14 15:18:56] ClientThread_ServerC@1.1.1.3-thread_2-12/15:12 27<br>[2012-11-14 15:18:56] Start thread-ClientThread_ServerC@1.1.1.3-thread_4<br>[2012-11-14 15:18:56] ClientThread_ServerC@1.1.1.3-thread_3-13/15:13 28<br>[2012-11-14 15:18:56] ClientThread_ServerC@1.1.1.3-thread_4-14/15:14 29<br>[2012-11-14 15:19:01] ClientThread_ServerB@1.1.1.2-thread_0-5/15:5 20<br>[2012-11-14 15:19:01] ClientThread_ServerA@1.1.1.1-thread_3-3/15:3 18<br>[2012-11-14 15:19:01] ClientThread_ServerA@1.1.1.1-thread_0-0/15:15 30<br>[2012-11-14 15:19:01] ClientThread_ServerB@1.1.1.2-thread_1-6/15:6 21<br>[2012-11-14 15:19:01] ClientThread_ServerA@1.1.1.1-thread_1-1/15:1 16<br>[2012-11-14 15:19:01] ClientThread_ServerC@1.1.1.3-thread_0-10/15:10 25<br>[2012-11-14 15:19:01] ClientThread_ServerA@1.1.1.1-thread_2-2/15:2 17<br>[2012-11-14 15:19:01] ClientThread_ServerB@1.1.1.2-thread_2-7/15:7 22<br>[2012-11-14 15:19:01] ClientThread_ServerC@1.1.1.3-thread_1-11/15:11 26<br>[2012-11-14 15:19:01] ClientThread_ServerB@1.1.1.2-thread_3-8/15:8 23<br>[2012-11-14 15:19:01] ClientThread_ServerA@1.1.1.1-thread_4-4/15:4 19<br>[2012-11-14 15:19:01] ClientThread_ServerC@1.1.1.3-thread_2-12/15:12 27<br>[2012-11-14 15:19:01] ClientThread_ServerB@1.1.1.2-thread_4-9/15:9 24<br>[2012-11-14 15:19:01] ClientThread_ServerC@1.1.1.3-thread_3-13/15:13 28<br>[2012-11-14 15:19:01] ClientThread_ServerC@1.1.1.3-thread_4-14/15:14 29<br>[2012-11-14 15:19:02] Thread-0 get an event.Path:/demo/1.1.1.1,state:SyncConnected,type:NodeDeleted<br>[2012-11-14 15:19:02] In event: NodeDeleted<br>[2012-11-14 15:19:02] ================<br>[2012-11-14 15:19:02] ServerA@1.1.1.1:freshing…<br>[2012-11-14 15:19:02] Thread-12 get an event.Path:/demo/1.1.1.1,state:SyncConnected,type:NodeDeleted<br>[2012-11-14 15:19:02] In event: NodeDeleted<br>[2012-11-14 15:19:02] ================<br>[2012-11-14 15:19:02] ServerC@1.1.1.3:freshing…<br>[2012-11-14 15:19:02] Thread-6 get an event.Path:/demo/1.1.1.1,state:SyncConnected,type:NodeDeleted<br>[2012-11-14 15:19:02] In event: NodeDeleted<br>[2012-11-14 15:19:02] ================<br>[2012-11-14 15:19:02] ServerB@1.1.1.2:freshing…<br>[2012-11-14 15:19:02] SYSTEM VERSION: 1<br>[2012-11-14 15:19:02] SYSTEM VERSION: 1<br>[2012-11-14 15:19:02] SYSTEM VERSION: 1<br>[2012-11-14 15:19:02] Server count:2<br>[2012-11-14 15:19:02] Server count:2<br>Did not get the mod number for ServerA@1.1.1.1<br>[2012-11-14 15:19:02] ServerA@1.1.1.1:end freshing…<br>[2012-11-14 15:19:02] ================<br>[2012-11-14 15:19:02] End event: NodeDeleted<br>[2012-11-14 15:19:02] Thread-0 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:02] In event: NodeChildrenChanged<br>[2012-11-14 15:19:02] ================<br>[2012-11-14 15:19:02] ServerA@1.1.1.1:freshing…<br>[2012-11-14 15:19:02] Server count:2<br>[2012-11-14 15:19:02] ServerC@1.1.1.3, mod=2,base=10<br>[2012-11-14 15:19:02] ClientThread_ServerC@1.1.1.3-thread_0:10/10<br>[2012-11-14 15:19:02] ClientThread_ServerC@1.1.1.3-thread_1:11/10<br>[2012-11-14 15:19:02] ClientThread_ServerC@1.1.1.3-thread_2:12/10<br>[2012-11-14 15:19:02] ClientThread_ServerC@1.1.1.3-thread_3:13/10<br>[2012-11-14 15:19:02] ClientThread_ServerC@1.1.1.3-thread_4:14/10<br>[2012-11-14 15:19:02] ServerC@1.1.1.3:end freshing…<br>[2012-11-14 15:19:02] ================<br>[2012-11-14 15:19:02] End event: NodeDeleted<br>[2012-11-14 15:19:02] Thread-12 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:02] In event: NodeChildrenChanged<br>[2012-11-14 15:19:02] ================<br>[2012-11-14 15:19:02] ServerC@1.1.1.3:freshing…<br>[2012-11-14 15:19:02] ServerB@1.1.1.2, mod=1,base=10<br>[2012-11-14 15:19:02] SYSTEM VERSION: 1<br>[2012-11-14 15:19:02] ClientThread_ServerB@1.1.1.2-thread_0:5/10<br>[2012-11-14 15:19:02] ClientThread_ServerB@1.1.1.2-thread_1:6/10<br>[2012-11-14 15:19:02] ClientThread_ServerB@1.1.1.2-thread_2:7/10<br>[2012-11-14 15:19:02] ClientThread_ServerB@1.1.1.2-thread_3:8/10<br>[2012-11-14 15:19:02] ClientThread_ServerB@1.1.1.2-thread_4:9/10<br>[2012-11-14 15:19:02] ServerB@1.1.1.2:end freshing…<br>[2012-11-14 15:19:02] ================<br>[2012-11-14 15:19:02] End event: NodeDeleted<br>[2012-11-14 15:19:02] Thread-6 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:02] In event: NodeChildrenChanged<br>[2012-11-14 15:19:02] ================<br>[2012-11-14 15:19:02] ServerB@1.1.1.2:freshing…<br>[2012-11-14 15:19:02] SYSTEM VERSION: 1<br>[2012-11-14 15:19:02] Server count:2<br>[2012-11-14 15:19:02] ServerA@1.1.1.1:end freshing…<br>[2012-11-14 15:19:02] ================<br>[2012-11-14 15:19:02] End event: NodeChildrenChanged<br>Did not get the mod number for ServerA@1.1.1.1<br>[2012-11-14 15:19:02] SYSTEM VERSION: 1<br>[2012-11-14 15:19:02] Server count:2<br>[2012-11-14 15:19:02] Server count:2<br>[2012-11-14 15:19:02] ServerC@1.1.1.3, mod=2,base=10<br>[2012-11-14 15:19:02] ClientThread_ServerC@1.1.1.3-thread_0:10/10<br>[2012-11-14 15:19:02] ClientThread_ServerC@1.1.1.3-thread_1:11/10<br>[2012-11-14 15:19:02] ClientThread_ServerC@1.1.1.3-thread_2:12/10<br>[2012-11-14 15:19:02] ClientThread_ServerC@1.1.1.3-thread_3:13/10<br>[2012-11-14 15:19:02] ServerB@1.1.1.2, mod=1,base=10<br>[2012-11-14 15:19:02] ClientThread_ServerC@1.1.1.3-thread_4:14/10<br>[2012-11-14 15:19:02] ClientThread_ServerB@1.1.1.2-thread_0:5/10<br>[2012-11-14 15:19:02] ServerC@1.1.1.3:end freshing…<br>[2012-11-14 15:19:02] ClientThread_ServerB@1.1.1.2-thread_1:6/10<br>[2012-11-14 15:19:02] ================<br>[2012-11-14 15:19:02] End event: NodeChildrenChanged<br>[2012-11-14 15:19:02] ClientThread_ServerB@1.1.1.2-thread_2:7/10<br>[2012-11-14 15:19:02] ClientThread_ServerB@1.1.1.2-thread_3:8/10<br>[2012-11-14 15:19:02] ClientThread_ServerB@1.1.1.2-thread_4:9/10<br>[2012-11-14 15:19:02] ServerB@1.1.1.2:end freshing…<br>[2012-11-14 15:19:02] ================<br>[2012-11-14 15:19:02] End event: NodeChildrenChanged<br>[2012-11-14 15:19:06] ClientThread_ServerA@1.1.1.1-thread_1-1/10:1 11 21<br>[2012-11-14 15:19:06] ClientThread_ServerB@1.1.1.2-thread_1-6/10:6 16 26<br>[2012-11-14 15:19:06] ClientThread_ServerB@1.1.1.2-thread_0-5/10:5 15 25<br>[2012-11-14 15:19:06] ClientThread_ServerA@1.1.1.1-thread_2-2/10:2 12 22<br>[2012-11-14 15:19:06] ClientThread_ServerC@1.1.1.3-thread_0-10/10:<br>[2012-11-14 15:19:06] ClientThread_ServerA@1.1.1.1-thread_3-3/10:3 13 23<br>[2012-11-14 15:19:06] ClientThread_ServerA@1.1.1.1-thread_0-0/10:10 20 30<br>[2012-11-14 15:19:06] ClientThread_ServerA@1.1.1.1-thread_4-4/10:4 14 24<br>[2012-11-14 15:19:06] ClientThread_ServerB@1.1.1.2-thread_2-7/10:7 17 27<br>[2012-11-14 15:19:06] ClientThread_ServerB@1.1.1.2-thread_3-8/10:8 18 28<br>[2012-11-14 15:19:06] ClientThread_ServerC@1.1.1.3-thread_1-11/10:<br>[2012-11-14 15:19:06] ClientThread_ServerC@1.1.1.3-thread_2-12/10:<br>[2012-11-14 15:19:06] ClientThread_ServerB@1.1.1.2-thread_4-9/10:9 19 29<br>[2012-11-14 15:19:06] ClientThread_ServerC@1.1.1.3-thread_3-13/10:<br>[2012-11-14 15:19:06] ClientThread_ServerC@1.1.1.3-thread_4-14/10:<br>[2012-11-14 15:19:07] Thread-0 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:07] In event: NodeChildrenChanged<br>[2012-11-14 15:19:07] ================<br>[2012-11-14 15:19:07] ServerA@1.1.1.1:freshing…<br>[2012-11-14 15:19:07] Thread-12 get an event.Path:/demo/1.1.1.2,state:SyncConnected,type:NodeDeleted<br>[2012-11-14 15:19:07] In event: NodeDeleted<br>[2012-11-14 15:19:07] ================<br>[2012-11-14 15:19:07] ServerC@1.1.1.3:freshing…<br>[2012-11-14 15:19:07] Thread-6 get an event.Path:/demo/1.1.1.2,state:SyncConnected,type:NodeDeleted<br>[2012-11-14 15:19:07] In event: NodeDeleted<br>[2012-11-14 15:19:07] ================<br>[2012-11-14 15:19:07] ServerB@1.1.1.2:freshing…<br>[2012-11-14 15:19:07] SYSTEM VERSION: 1<br>Did not get the mod number for ServerA@1.1.1.1<br>[2012-11-14 15:19:07] Server count:1<br>[2012-11-14 15:19:07] ServerA@1.1.1.1:end freshing…<br>[2012-11-14 15:19:07] ================<br>[2012-11-14 15:19:07] End event: NodeChildrenChanged<br>[2012-11-14 15:19:07] SYSTEM VERSION: 1<br>[2012-11-14 15:19:07] SYSTEM VERSION: 1<br>[2012-11-14 15:19:07] Server count:1<br>[2012-11-14 15:19:07] Server count:1<br>[2012-11-14 15:19:07] ServerB@1.1.1.2:end freshing…<br>[2012-11-14 15:19:07] ================<br>[2012-11-14 15:19:07] End event: NodeDeleted<br>[2012-11-14 15:19:07] Thread-6 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:07] In event: NodeChildrenChanged<br>[2012-11-14 15:19:07] ================<br>[2012-11-14 15:19:07] ServerB@1.1.1.2:freshing…<br>Did not get the mod number for ServerB@1.1.1.2<br>[2012-11-14 15:19:07] ServerC@1.1.1.3, mod=2,base=5<br>[2012-11-14 15:19:07] ClientThread_ServerC@1.1.1.3-thread_0:10/5<br>[2012-11-14 15:19:07] ClientThread_ServerC@1.1.1.3-thread_1:11/5<br>[2012-11-14 15:19:07] ClientThread_ServerC@1.1.1.3-thread_2:12/5<br>[2012-11-14 15:19:07] ClientThread_ServerC@1.1.1.3-thread_3:13/5<br>[2012-11-14 15:19:07] ClientThread_ServerC@1.1.1.3-thread_4:14/5<br>[2012-11-14 15:19:07] ServerC@1.1.1.3:end freshing…<br>[2012-11-14 15:19:07] ================<br>[2012-11-14 15:19:07] End event: NodeDeleted<br>[2012-11-14 15:19:07] Thread-12 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:07] In event: NodeChildrenChanged<br>[2012-11-14 15:19:07] ================<br>[2012-11-14 15:19:07] ServerC@1.1.1.3:freshing…<br>[2012-11-14 15:19:07] SYSTEM VERSION: 1<br>Did not get the mod number for ServerB@1.1.1.2<br>[2012-11-14 15:19:07] Server count:1<br>[2012-11-14 15:19:07] ServerB@1.1.1.2:end freshing…<br>[2012-11-14 15:19:07] ================<br>[2012-11-14 15:19:07] End event: NodeChildrenChanged<br>[2012-11-14 15:19:07] SYSTEM VERSION: 1<br>[2012-11-14 15:19:07] Server count:1<br>[2012-11-14 15:19:07] ServerC@1.1.1.3, mod=2,base=5<br>[2012-11-14 15:19:07] ClientThread_ServerC@1.1.1.3-thread_0:10/5<br>[2012-11-14 15:19:07] ClientThread_ServerC@1.1.1.3-thread_1:11/5<br>[2012-11-14 15:19:07] ClientThread_ServerC@1.1.1.3-thread_2:12/5<br>[2012-11-14 15:19:07] ClientThread_ServerC@1.1.1.3-thread_3:13/5<br>[2012-11-14 15:19:07] ClientThread_ServerC@1.1.1.3-thread_4:14/5<br>[2012-11-14 15:19:07] ServerC@1.1.1.3:end freshing…<br>[2012-11-14 15:19:07] ================<br>[2012-11-14 15:19:07] End event: NodeChildrenChanged<br>[2012-11-14 15:19:11] ClientThread_ServerB@1.1.1.2-thread_1-6/5:<br>[2012-11-14 15:19:11] ClientThread_ServerA@1.1.1.1-thread_0-0/5:5 10 15 20 25 30<br>[2012-11-14 15:19:11] ClientThread_ServerC@1.1.1.3-thread_0-10/5:<br>[2012-11-14 15:19:11] ClientThread_ServerA@1.1.1.1-thread_1-1/5:1 6 11 16 21 26<br>[2012-11-14 15:19:11] ClientThread_ServerA@1.1.1.1-thread_3-3/5:3 8 13 18 23 28<br>[2012-11-14 15:19:11] ClientThread_ServerB@1.1.1.2-thread_0-5/5:<br>[2012-11-14 15:19:11] ClientThread_ServerA@1.1.1.1-thread_2-2/5:2 7 12 17 22 27<br>[2012-11-14 15:19:11] ClientThread_ServerC@1.1.1.3-thread_1-11/5:<br>[2012-11-14 15:19:11] ClientThread_ServerB@1.1.1.2-thread_3-8/5:<br>[2012-11-14 15:19:11] ClientThread_ServerB@1.1.1.2-thread_2-7/5:<br>[2012-11-14 15:19:11] ClientThread_ServerA@1.1.1.1-thread_4-4/5:4 9 14 19 24 29<br>[2012-11-14 15:19:11] ClientThread_ServerB@1.1.1.2-thread_4-9/5:<br>[2012-11-14 15:19:11] ClientThread_ServerC@1.1.1.3-thread_2-12/5:<br>[2012-11-14 15:19:11] ClientThread_ServerC@1.1.1.3-thread_4-14/5:<br>[2012-11-14 15:19:11] ClientThread_ServerC@1.1.1.3-thread_3-13/5:<br>[2012-11-14 15:19:12] Thread-0 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:12] In event: NodeChildrenChanged<br>[2012-11-14 15:19:12] ================<br>[2012-11-14 15:19:12] ServerA@1.1.1.1:freshing…<br>[2012-11-14 15:19:12] Thread-12 get an event.Path:/demo/1.1.1.3,state:SyncConnected,type:NodeDeleted<br>[2012-11-14 15:19:12] In event: NodeDeleted<br>[2012-11-14 15:19:12] ================<br>[2012-11-14 15:19:12] ServerC@1.1.1.3:freshing…<br>[2012-11-14 15:19:12] Thread-6 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:12] In event: NodeChildrenChanged<br>[2012-11-14 15:19:12] ================<br>[2012-11-14 15:19:12] ServerB@1.1.1.2:freshing…<br>[2012-11-14 15:19:12] SYSTEM VERSION: 1<br>[2012-11-14 15:19:12] SYSTEM VERSION: 1<br>[2012-11-14 15:19:12] Server count:0<br>[2012-11-14 15:19:12] ServerB@1.1.1.2:end freshing…<br>[2012-11-14 15:19:12] ================<br>[2012-11-14 15:19:12] End event: NodeChildrenChanged<br>[2012-11-14 15:19:12] SYSTEM VERSION: 1<br>[2012-11-14 15:19:12] Server count:0<br>[2012-11-14 15:19:12] ServerA@1.1.1.1:end freshing…<br>[2012-11-14 15:19:12] ================<br>[2012-11-14 15:19:12] End event: NodeChildrenChanged<br>[2012-11-14 15:19:12] Server count:0<br>[2012-11-14 15:19:12] ServerC@1.1.1.3:end freshing…<br>[2012-11-14 15:19:12] ================<br>[2012-11-14 15:19:12] End event: NodeDeleted<br>[2012-11-14 15:19:12] Thread-12 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:12] In event: NodeChildrenChanged<br>[2012-11-14 15:19:12] ================<br>[2012-11-14 15:19:12] ServerC@1.1.1.3:freshing…<br>[2012-11-14 15:19:12] SYSTEM VERSION: 1<br>[2012-11-14 15:19:12] Server count:0<br>[2012-11-14 15:19:12] ServerC@1.1.1.3:end freshing…<br>[2012-11-14 15:19:12] ================<br>[2012-11-14 15:19:12] End event: NodeChildrenChanged<br>[2012-11-14 15:19:16] ClientThread_ServerB@1.1.1.2-thread_1: did not get server_count and modNum!!!<br>[2012-11-14 15:19:16] ClientThread_ServerA@1.1.1.1-thread_2: did not get server_count and modNum!!!<br>[2012-11-14 15:19:16] ClientThread_ServerB@1.1.1.2-thread_0: did not get server_count and modNum!!!<br>[2012-11-14 15:19:16] ClientThread_ServerA@1.1.1.1-thread_1: did not get server_count and modNum!!!<br>[2012-11-14 15:19:16] ClientThread_ServerC@1.1.1.3-thread_0: did not get server_count and modNum!!!<br>[2012-11-14 15:19:16] ClientThread_ServerA@1.1.1.1-thread_3: did not get server_count and modNum!!!<br>[2012-11-14 15:19:16] ClientThread_ServerA@1.1.1.1-thread_0: did not get server_count and modNum!!!<br>[2012-11-14 15:19:16] ClientThread_ServerA@1.1.1.1-thread_4: did not get server_count and modNum!!!<br>[2012-11-14 15:19:16] ClientThread_ServerB@1.1.1.2-thread_3: did not get server_count and modNum!!!<br>[2012-11-14 15:19:16] ClientThread_ServerC@1.1.1.3-thread_1: did not get server_count and modNum!!!<br>[2012-11-14 15:19:16] ClientThread_ServerB@1.1.1.2-thread_2: did not get server_count and modNum!!!<br>[2012-11-14 15:19:16] ClientThread_ServerB@1.1.1.2-thread_4: did not get server_count and modNum!!!<br>[2012-11-14 15:19:16] ClientThread_ServerC@1.1.1.3-thread_2: did not get server_count and modNum!!!<br>[2012-11-14 15:19:16] ClientThread_ServerC@1.1.1.3-thread_3: did not get server_count and modNum!!!<br>[2012-11-14 15:19:16] ClientThread_ServerC@1.1.1.3-thread_4: did not get server_count and modNum!!!<br>[2012-11-14 15:19:20] Thread-0 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:20] In event: NodeChildrenChanged<br>[2012-11-14 15:19:20] ================<br>[2012-11-14 15:19:20] ServerA@1.1.1.1:freshing…<br>[2012-11-14 15:19:20] Thread-6 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:20] In event: NodeChildrenChanged<br>[2012-11-14 15:19:20] ================<br>[2012-11-14 15:19:20] ServerB@1.1.1.2:freshing…<br>[2012-11-14 15:19:20] Thread-12 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:20] In event: NodeChildrenChanged<br>[2012-11-14 15:19:20] ================<br>[2012-11-14 15:19:20] ServerC@1.1.1.3:freshing…<br>[2012-11-14 15:19:20] SYSTEM VERSION: 1<br>[2012-11-14 15:19:20] SYSTEM VERSION: 1<br>[2012-11-14 15:19:20] SYSTEM VERSION: 1<br>[2012-11-14 15:19:20] Server count:1<br>Did not get the mod number for ServerC@1.1.1.3<br>[2012-11-14 15:19:20] Server count:1<br>[2012-11-14 15:19:20] ServerC@1.1.1.3:end freshing…<br>[2012-11-14 15:19:20] ================<br>[2012-11-14 15:19:20] End event: NodeChildrenChanged<br>[2012-11-14 15:19:20] ServerA@1.1.1.1, mod=0,base=5<br>[2012-11-14 15:19:20] ClientThread_ServerA@1.1.1.1-thread_0:0/5<br>[2012-11-14 15:19:20] ClientThread_ServerA@1.1.1.1-thread_1:1/5<br>[2012-11-14 15:19:20] ClientThread_ServerA@1.1.1.1-thread_2:2/5<br>[2012-11-14 15:19:20] ClientThread_ServerA@1.1.1.1-thread_3:3/5<br>[2012-11-14 15:19:20] ClientThread_ServerA@1.1.1.1-thread_4:4/5<br>[2012-11-14 15:19:20] ServerA@1.1.1.1:end freshing…<br>[2012-11-14 15:19:20] ================<br>[2012-11-14 15:19:20] End event: NodeChildrenChanged<br>Did not get the mod number for ServerB@1.1.1.2<br>[2012-11-14 15:19:20] Server count:1<br>[2012-11-14 15:19:20] ServerB@1.1.1.2:end freshing…<br>[2012-11-14 15:19:20] ================<br>[2012-11-14 15:19:20] End event: NodeChildrenChanged<br>[2012-11-14 15:19:21] ClientThread_ServerB@1.1.1.2-thread_1-6/5:<br>[2012-11-14 15:19:21] ClientThread_ServerA@1.1.1.1-thread_0-0/5:5 10 15 20 25 30<br>[2012-11-14 15:19:21] ClientThread_ServerA@1.1.1.1-thread_2-2/5:2 7 12 17 22 27<br>[2012-11-14 15:19:21] ClientThread_ServerA@1.1.1.1-thread_1-1/5:1 6 11 16 21 26<br>[2012-11-14 15:19:21] ClientThread_ServerA@1.1.1.1-thread_3-3/5:3 8 13 18 23 28<br>[2012-11-14 15:19:21] ClientThread_ServerC@1.1.1.3-thread_0-10/5:<br>[2012-11-14 15:19:21] ClientThread_ServerB@1.1.1.2-thread_0-5/5:<br>[2012-11-14 15:19:21] ClientThread_ServerC@1.1.1.3-thread_1-11/5:<br>[2012-11-14 15:19:21] ClientThread_ServerB@1.1.1.2-thread_3-8/5:<br>[2012-11-14 15:19:21] ClientThread_ServerA@1.1.1.1-thread_4-4/5:4 9 14 19 24 29<br>[2012-11-14 15:19:21] ClientThread_ServerB@1.1.1.2-thread_2-7/5:<br>[2012-11-14 15:19:21] ClientThread_ServerC@1.1.1.3-thread_2-12/5:<br>[2012-11-14 15:19:21] ClientThread_ServerB@1.1.1.2-thread_4-9/5:<br>[2012-11-14 15:19:21] ClientThread_ServerC@1.1.1.3-thread_4-14/5:<br>[2012-11-14 15:19:21] ClientThread_ServerC@1.1.1.3-thread_3-13/5:<br>[2012-11-14 15:19:25] Thread-0 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:25] In event: NodeChildrenChanged<br>[2012-11-14 15:19:25] ================<br>[2012-11-14 15:19:25] ServerA@1.1.1.1:freshing…<br>[2012-11-14 15:19:25] Thread-6 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:25] In event: NodeChildrenChanged<br>[2012-11-14 15:19:25] ================<br>[2012-11-14 15:19:25] ServerB@1.1.1.2:freshing…<br>[2012-11-14 15:19:25] Thread-12 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:25] In event: NodeChildrenChanged<br>[2012-11-14 15:19:25] ================<br>[2012-11-14 15:19:25] ServerC@1.1.1.3:freshing…<br>[2012-11-14 15:19:25] SYSTEM VERSION: 1<br>[2012-11-14 15:19:25] SYSTEM VERSION: 1<br>[2012-11-14 15:19:25] SYSTEM VERSION: 1<br>[2012-11-14 15:19:25] Server count:2<br>[2012-11-14 15:19:25] ServerC@1.1.1.3:end freshing…<br>[2012-11-14 15:19:25] ================<br>Did not get the mod number for ServerC@1.1.1.3<br>[2012-11-14 15:19:25] End event: NodeChildrenChanged<br>[2012-11-14 15:19:25] Server count:2<br>[2012-11-14 15:19:25] Server count:2<br>[2012-11-14 15:19:25] ServerB@1.1.1.2, mod=1,base=10<br>[2012-11-14 15:19:25] ClientThread_ServerB@1.1.1.2-thread_0:5/10<br>[2012-11-14 15:19:25] ClientThread_ServerB@1.1.1.2-thread_1:6/10<br>[2012-11-14 15:19:25] ClientThread_ServerB@1.1.1.2-thread_2:7/10<br>[2012-11-14 15:19:25] ClientThread_ServerB@1.1.1.2-thread_3:8/10<br>[2012-11-14 15:19:25] ClientThread_ServerB@1.1.1.2-thread_4:9/10<br>[2012-11-14 15:19:25] ServerB@1.1.1.2:end freshing…<br>[2012-11-14 15:19:25] ================<br>[2012-11-14 15:19:25] End event: NodeChildrenChanged<br>[2012-11-14 15:19:25] ServerA@1.1.1.1, mod=0,base=10<br>[2012-11-14 15:19:25] ClientThread_ServerA@1.1.1.1-thread_0:0/10<br>[2012-11-14 15:19:25] ClientThread_ServerA@1.1.1.1-thread_1:1/10<br>[2012-11-14 15:19:25] ClientThread_ServerA@1.1.1.1-thread_2:2/10<br>[2012-11-14 15:19:25] ClientThread_ServerA@1.1.1.1-thread_3:3/10<br>[2012-11-14 15:19:25] ClientThread_ServerA@1.1.1.1-thread_4:4/10<br>[2012-11-14 15:19:25] ServerA@1.1.1.1:end freshing…<br>[2012-11-14 15:19:25] ================<br>[2012-11-14 15:19:25] End event: NodeChildrenChanged<br>[2012-11-14 15:19:26] ClientThread_ServerA@1.1.1.1-thread_2-2/10:2 12 22<br>[2012-11-14 15:19:26] ClientThread_ServerA@1.1.1.1-thread_3-3/10:3 13 23<br>[2012-11-14 15:19:26] ClientThread_ServerA@1.1.1.1-thread_0-0/10:10 20 30<br>[2012-11-14 15:19:26] ClientThread_ServerA@1.1.1.1-thread_1-1/10:1 11 21<br>[2012-11-14 15:19:26] ClientThread_ServerC@1.1.1.3-thread_0-10/10:<br>[2012-11-14 15:19:26] ClientThread_ServerB@1.1.1.2-thread_0-5/10:5 15 25<br>[2012-11-14 15:19:26] ClientThread_ServerB@1.1.1.2-thread_1-6/10:6 16 26<br>[2012-11-14 15:19:26] ClientThread_ServerA@1.1.1.1-thread_4-4/10:4 14 24<br>[2012-11-14 15:19:26] ClientThread_ServerC@1.1.1.3-thread_1-11/10:<br>[2012-11-14 15:19:26] ClientThread_ServerB@1.1.1.2-thread_3-8/10:8 18 28<br>[2012-11-14 15:19:26] ClientThread_ServerB@1.1.1.2-thread_2-7/10:7 17 27<br>[2012-11-14 15:19:26] ClientThread_ServerB@1.1.1.2-thread_4-9/10:9 19 29<br>[2012-11-14 15:19:26] ClientThread_ServerC@1.1.1.3-thread_2-12/10:<br>[2012-11-14 15:19:26] ClientThread_ServerC@1.1.1.3-thread_4-14/10:<br>[2012-11-14 15:19:26] ClientThread_ServerC@1.1.1.3-thread_3-13/10:<br>[2012-11-14 15:19:31] ClientThread_ServerA@1.1.1.1-thread_1-1/10:1 11 21<br>[2012-11-14 15:19:31] ClientThread_ServerA@1.1.1.1-thread_0-0/10:10 20 30<br>[2012-11-14 15:19:31] ClientThread_ServerB@1.1.1.2-thread_0-5/10:5 15 25<br>[2012-11-14 15:19:31] ClientThread_ServerC@1.1.1.3-thread_0-10/10:<br>[2012-11-14 15:19:31] ClientThread_ServerA@1.1.1.1-thread_2-2/10:2 12 22<br>[2012-11-14 15:19:31] ClientThread_ServerA@1.1.1.1-thread_3-3/10:3 13 23<br>[2012-11-14 15:19:31] ClientThread_ServerB@1.1.1.2-thread_1-6/10:6 16 26<br>[2012-11-14 15:19:31] ClientThread_ServerC@1.1.1.3-thread_1-11/10:<br>[2012-11-14 15:19:31] ClientThread_ServerA@1.1.1.1-thread_4-4/10:4 14 24<br>[2012-11-14 15:19:31] ClientThread_ServerB@1.1.1.2-thread_3-8/10:8 18 28<br>[2012-11-14 15:19:31] ClientThread_ServerB@1.1.1.2-thread_2-7/10:7 17 27<br>[2012-11-14 15:19:31] ClientThread_ServerB@1.1.1.2-thread_4-9/10:9 19 29<br>[2012-11-14 15:19:31] ClientThread_ServerC@1.1.1.3-thread_2-12/10:<br>[2012-11-14 15:19:31] ClientThread_ServerC@1.1.1.3-thread_3-13/10:<br>[2012-11-14 15:19:31] ClientThread_ServerC@1.1.1.3-thread_4-14/10:<br>[2012-11-14 15:19:31] Thread-0 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:31] In event: NodeChildrenChanged<br>[2012-11-14 15:19:31] ================<br>[2012-11-14 15:19:31] ServerA@1.1.1.1:freshing…<br>[2012-11-14 15:19:31] Thread-12 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:31] In event: NodeChildrenChanged<br>[2012-11-14 15:19:31] ================<br>[2012-11-14 15:19:31] ServerC@1.1.1.3:freshing…<br>[2012-11-14 15:19:31] Thread-6 get an event.Path:/demo,state:SyncConnected,type:NodeChildrenChanged<br>[2012-11-14 15:19:31] In event: NodeChildrenChanged<br>[2012-11-14 15:19:31] ================<br>[2012-11-14 15:19:31] ServerB@1.1.1.2:freshing…<br>[2012-11-14 15:19:31] SYSTEM VERSION: 1<br>[2012-11-14 15:19:31] SYSTEM VERSION: 1<br>[2012-11-14 15:19:31] SYSTEM VERSION: 1<br>[2012-11-14 15:19:31] Server count:3<br>[2012-11-14 15:19:31] Server count:3<br>[2012-11-14 15:19:31] ServerA@1.1.1.1, mod=0,base=15<br>[2012-11-14 15:19:31] ClientThread_ServerA@1.1.1.1-thread_0:0/15<br>[2012-11-14 15:19:31] ClientThread_ServerA@1.1.1.1-thread_1:1/15<br>[2012-11-14 15:19:31] ClientThread_ServerA@1.1.1.1-thread_2:2/15<br>[2012-11-14 15:19:31] ClientThread_ServerA@1.1.1.1-thread_3:3/15<br>[2012-11-14 15:19:31] ClientThread_ServerA@1.1.1.1-thread_4:4/15<br>[2012-11-14 15:19:31] ServerA@1.1.1.1:end freshing…<br>[2012-11-14 15:19:31] ================<br>[2012-11-14 15:19:31] End event: NodeChildrenChanged<br>[2012-11-14 15:19:31] Server count:3<br>[2012-11-14 15:19:31] ServerC@1.1.1.3, mod=2,base=15<br>[2012-11-14 15:19:31] ClientThread_ServerC@1.1.1.3-thread_0:10/15<br>[2012-11-14 15:19:31] ClientThread_ServerC@1.1.1.3-thread_1:11/15<br>[2012-11-14 15:19:31] ClientThread_ServerC@1.1.1.3-thread_2:12/15<br>[2012-11-14 15:19:31] ClientThread_ServerC@1.1.1.3-thread_3:13/15<br>[2012-11-14 15:19:31] ClientThread_ServerC@1.1.1.3-thread_4:14/15<br>[2012-11-14 15:19:31] ServerC@1.1.1.3:end freshing…<br>[2012-11-14 15:19:31] ================<br>[2012-11-14 15:19:31] End event: NodeChildrenChanged<br>[2012-11-14 15:19:31] ServerB@1.1.1.2, mod=1,base=15<br>[2012-11-14 15:19:31] ClientThread_ServerB@1.1.1.2-thread_0:5/15<br>[2012-11-14 15:19:31] ClientThread_ServerB@1.1.1.2-thread_1:6/15<br>[2012-11-14 15:19:31] ClientThread_ServerB@1.1.1.2-thread_2:7/15<br>[2012-11-14 15:19:31] ClientThread_ServerB@1.1.1.2-thread_3:8/15<br>[2012-11-14 15:19:31] ClientThread_ServerB@1.1.1.2-thread_4:9/15<br>[2012-11-14 15:19:31] ServerB@1.1.1.2:end freshing…<br>[2012-11-14 15:19:31] ================<br>[2012-11-14 15:19:31] End event: NodeChildrenChanged<br>[2012-11-14 15:19:36] ClientThread_ServerB@1.1.1.2-thread_0-5/15:5 20<br>[2012-11-14 15:19:36] ClientThread_ServerA@1.1.1.1-thread_2-2/15:2 17<br>[2012-11-14 15:19:36] ClientThread_ServerA@1.1.1.1-thread_3-3/15:3 18<br>[2012-11-14 15:19:36] ClientThread_ServerC@1.1.1.3-thread_0-10/15:10 25<br>[2012-11-14 15:19:36] ClientThread_ServerA@1.1.1.1-thread_0-0/15:15 30<br>[2012-11-14 15:19:36] ClientThread_ServerA@1.1.1.1-thread_1-1/15:1 16<br>[2012-11-14 15:19:36] ClientThread_ServerB@1.1.1.2-thread_1-6/15:6 21<br>[2012-11-14 15:19:36] ClientThread_ServerC@1.1.1.3-thread_1-11/15:11 26<br>[2012-11-14 15:19:36] ClientThread_ServerB@1.1.1.2-thread_3-8/15:8 23<br>[2012-11-14 15:19:36] ClientThread_ServerA@1.1.1.1-thread_4-4/15:4 19<br>[2012-11-14 15:19:36] ClientThread_ServerB@1.1.1.2-thread_2-7/15:7 22<br>[2012-11-14 15:19:36] ClientThread_ServerC@1.1.1.3-thread_2-12/15:12 27<br>[2012-11-14 15:19:36] ClientThread_ServerB@1.1.1.2-thread_4-9/15:9 24<br>[2012-11-14 15:19:36] ClientThread_ServerC@1.1.1.3-thread_4-14/15:14 29<br>[2012-11-14 15:19:36] ClientThread_ServerC@1.1.1.3-thread_3-13/15:13 28<br>[2012-11-14 15:19:41] ClientThread_ServerC@1.1.1.3-thread_0-10/15:10 25<br>[2012-11-14 15:19:41] ClientThread_ServerA@1.1.1.1-thread_0-0/15:15 30<br>[2012-11-14 15:19:41] ClientThread_ServerB@1.1.1.2-thread_1-6/15:6 21<br>[2012-11-14 15:19:41] ClientThread_ServerA@1.1.1.1-thread_3-3/15:3 18<br>[2012-11-14 15:19:41] ClientThread_ServerB@1.1.1.2-thread_0-5/15:5 20<br>[2012-11-14 15:19:41] ClientThread_ServerA@1.1.1.1-thread_1-1/15:1 16<br>[2012-11-14 15:19:41] ClientThread_ServerA@1.1.1.1-thread_2-2/15:2 17<br>[2012-11-14 15:19:41] ClientThread_ServerB@1.1.1.2-thread_3-8/15:8 23<br>[2012-11-14 15:19:41] ClientThread_ServerB@1.1.1.2-thread_2-7/15:7 22<br>[2012-11-14 15:19:41] ClientThread_ServerA@1.1.1.1-thread_4-4/15:4 19<br>[2012-11-14 15:19:41] ClientThread_ServerC@1.1.1.3-thread_1-11/15:11 26<br>[2012-11-14 15:19:41] ClientThread_ServerC@1.1.1.3-thread_2-12/15:12 27<br>[2012-11-14 15:19:41] ClientThread_ServerB@1.1.1.2-thread_4-9/15:9 24<br>[2012-11-14 15:19:41] ClientThread_ServerC@1.1.1.3-thread_4-14/15:14 29<br>[2012-11-14 15:19:41] ClientThread_ServerC@1.1.1.3-thread_3-13/15:13 28</p>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
